// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stock/stock.proto

package stock

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strconv "strconv"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type OrderType int32

const (
	MarketOrder OrderType = 0
	LimitOrder  OrderType = 1
)

var OrderType_name = map[int32]string{
	0: "MarketOrder",
	1: "LimitOrder",
}

var OrderType_value = map[string]int32{
	"MarketOrder": 0,
	"LimitOrder":  1,
}

func (OrderType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{0}
}

type Order_Side int32

const (
	//매도
	Ask Order_Side = 0
	//매수
	Bid Order_Side = 1
)

var Order_Side_name = map[int32]string{
	0: "Ask",
	1: "Bid",
}

var Order_Side_value = map[string]int32{
	"Ask": 0,
	"Bid": 1,
}

func (Order_Side) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{14, 0}
}

type AllMarketsReply struct {
	Codes []string `protobuf:"bytes,1,rep,name=codes,proto3" json:"codes,omitempty"`
}

func (m *AllMarketsReply) Reset()      { *m = AllMarketsReply{} }
func (*AllMarketsReply) ProtoMessage() {}
func (*AllMarketsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{0}
}
func (m *AllMarketsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AllMarketsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AllMarketsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AllMarketsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AllMarketsReply.Merge(m, src)
}
func (m *AllMarketsReply) XXX_Size() int {
	return m.Size()
}
func (m *AllMarketsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AllMarketsReply.DiscardUnknown(m)
}

var xxx_messageInfo_AllMarketsReply proto.InternalMessageInfo

func (m *AllMarketsReply) GetCodes() []string {
	if m != nil {
		return m.Codes
	}
	return nil
}

type Account struct {
	Code       string  `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
	Balance    float64 `protobuf:"fixed64,2,opt,name=balance,proto3" json:"balance,omitempty"`
	AvgByPrice float64 `protobuf:"fixed64,3,opt,name=avgByPrice,proto3" json:"avgByPrice,omitempty"`
	TotalPrice float64 `protobuf:"fixed64,4,opt,name=totalPrice,proto3" json:"totalPrice,omitempty"`
}

func (m *Account) Reset()      { *m = Account{} }
func (*Account) ProtoMessage() {}
func (*Account) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{1}
}
func (m *Account) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Account) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Account.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Account) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Account.Merge(m, src)
}
func (m *Account) XXX_Size() int {
	return m.Size()
}
func (m *Account) XXX_DiscardUnknown() {
	xxx_messageInfo_Account.DiscardUnknown(m)
}

var xxx_messageInfo_Account proto.InternalMessageInfo

func (m *Account) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *Account) GetBalance() float64 {
	if m != nil {
		return m.Balance
	}
	return 0
}

func (m *Account) GetAvgByPrice() float64 {
	if m != nil {
		return m.AvgByPrice
	}
	return 0
}

func (m *Account) GetTotalPrice() float64 {
	if m != nil {
		return m.TotalPrice
	}
	return 0
}

type AccountRequest struct {
	Account string `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
}

func (m *AccountRequest) Reset()      { *m = AccountRequest{} }
func (*AccountRequest) ProtoMessage() {}
func (*AccountRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{2}
}
func (m *AccountRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountRequest.Merge(m, src)
}
func (m *AccountRequest) XXX_Size() int {
	return m.Size()
}
func (m *AccountRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AccountRequest proto.InternalMessageInfo

func (m *AccountRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

type AccountReply struct {
	Info string `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *AccountReply) Reset()      { *m = AccountReply{} }
func (*AccountReply) ProtoMessage() {}
func (*AccountReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{3}
}
func (m *AccountReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountReply.Merge(m, src)
}
func (m *AccountReply) XXX_Size() int {
	return m.Size()
}
func (m *AccountReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountReply.DiscardUnknown(m)
}

var xxx_messageInfo_AccountReply proto.InternalMessageInfo

func (m *AccountReply) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

type TickRequest struct {
	Codes string `protobuf:"bytes,1,opt,name=codes,proto3" json:"codes,omitempty"`
}

func (m *TickRequest) Reset()      { *m = TickRequest{} }
func (*TickRequest) ProtoMessage() {}
func (*TickRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{4}
}
func (m *TickRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TickRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TickRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TickRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TickRequest.Merge(m, src)
}
func (m *TickRequest) XXX_Size() int {
	return m.Size()
}
func (m *TickRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TickRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TickRequest proto.InternalMessageInfo

func (m *TickRequest) GetCodes() string {
	if m != nil {
		return m.Codes
	}
	return ""
}

type TickReply struct {
	Price  float64          `protobuf:"fixed64,1,opt,name=price,proto3" json:"price,omitempty"`
	Date   *types.Timestamp `protobuf:"bytes,2,opt,name=date,proto3" json:"date,omitempty"`
	Volume float64          `protobuf:"fixed64,3,opt,name=volume,proto3" json:"volume,omitempty"`
}

func (m *TickReply) Reset()      { *m = TickReply{} }
func (*TickReply) ProtoMessage() {}
func (*TickReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{5}
}
func (m *TickReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TickReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TickReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TickReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TickReply.Merge(m, src)
}
func (m *TickReply) XXX_Size() int {
	return m.Size()
}
func (m *TickReply) XXX_DiscardUnknown() {
	xxx_messageInfo_TickReply.DiscardUnknown(m)
}

var xxx_messageInfo_TickReply proto.InternalMessageInfo

func (m *TickReply) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *TickReply) GetDate() *types.Timestamp {
	if m != nil {
		return m.Date
	}
	return nil
}

func (m *TickReply) GetVolume() float64 {
	if m != nil {
		return m.Volume
	}
	return 0
}

type ChartRequest struct {
	Code string           `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
	To   *types.Timestamp `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
}

func (m *ChartRequest) Reset()      { *m = ChartRequest{} }
func (*ChartRequest) ProtoMessage() {}
func (*ChartRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{6}
}
func (m *ChartRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChartRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChartRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChartRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChartRequest.Merge(m, src)
}
func (m *ChartRequest) XXX_Size() int {
	return m.Size()
}
func (m *ChartRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ChartRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ChartRequest proto.InternalMessageInfo

func (m *ChartRequest) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *ChartRequest) GetTo() *types.Timestamp {
	if m != nil {
		return m.To
	}
	return nil
}

type ChartReply struct {
	Data []*ChartData `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *ChartReply) Reset()      { *m = ChartReply{} }
func (*ChartReply) ProtoMessage() {}
func (*ChartReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{7}
}
func (m *ChartReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChartReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChartReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChartReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChartReply.Merge(m, src)
}
func (m *ChartReply) XXX_Size() int {
	return m.Size()
}
func (m *ChartReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ChartReply.DiscardUnknown(m)
}

var xxx_messageInfo_ChartReply proto.InternalMessageInfo

func (m *ChartReply) GetData() []*ChartData {
	if m != nil {
		return m.Data
	}
	return nil
}

type AccountsReply struct {
	Accounts []*Account `protobuf:"bytes,1,rep,name=accounts,proto3" json:"accounts,omitempty"`
}

func (m *AccountsReply) Reset()      { *m = AccountsReply{} }
func (*AccountsReply) ProtoMessage() {}
func (*AccountsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{8}
}
func (m *AccountsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountsReply.Merge(m, src)
}
func (m *AccountsReply) XXX_Size() int {
	return m.Size()
}
func (m *AccountsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountsReply.DiscardUnknown(m)
}

var xxx_messageInfo_AccountsReply proto.InternalMessageInfo

func (m *AccountsReply) GetAccounts() []*Account {
	if m != nil {
		return m.Accounts
	}
	return nil
}

type BuyRequest struct {
	Code   string    `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
	Otype  OrderType `protobuf:"varint,2,opt,name=otype,proto3,enum=stock.OrderType" json:"otype,omitempty"`
	Volume float64   `protobuf:"fixed64,3,opt,name=volume,proto3" json:"volume,omitempty"`
	Price  float64   `protobuf:"fixed64,4,opt,name=price,proto3" json:"price,omitempty"`
}

func (m *BuyRequest) Reset()      { *m = BuyRequest{} }
func (*BuyRequest) ProtoMessage() {}
func (*BuyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{9}
}
func (m *BuyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuyRequest.Merge(m, src)
}
func (m *BuyRequest) XXX_Size() int {
	return m.Size()
}
func (m *BuyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BuyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BuyRequest proto.InternalMessageInfo

func (m *BuyRequest) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *BuyRequest) GetOtype() OrderType {
	if m != nil {
		return m.Otype
	}
	return MarketOrder
}

func (m *BuyRequest) GetVolume() float64 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *BuyRequest) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

type BuyReply struct {
	Id        string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Code      string           `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
	AvgPrice  float64          `protobuf:"fixed64,3,opt,name=avgPrice,proto3" json:"avgPrice,omitempty"`
	Volume    float64          `protobuf:"fixed64,4,opt,name=volume,proto3" json:"volume,omitempty"`
	Fee       float64          `protobuf:"fixed64,5,opt,name=fee,proto3" json:"fee,omitempty"`
	Price     float64          `protobuf:"fixed64,6,opt,name=price,proto3" json:"price,omitempty"`
	CreatedAt *types.Timestamp `protobuf:"bytes,7,opt,name=createdAt,proto3" json:"createdAt,omitempty"`
}

func (m *BuyReply) Reset()      { *m = BuyReply{} }
func (*BuyReply) ProtoMessage() {}
func (*BuyReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{10}
}
func (m *BuyReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuyReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuyReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuyReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuyReply.Merge(m, src)
}
func (m *BuyReply) XXX_Size() int {
	return m.Size()
}
func (m *BuyReply) XXX_DiscardUnknown() {
	xxx_messageInfo_BuyReply.DiscardUnknown(m)
}

var xxx_messageInfo_BuyReply proto.InternalMessageInfo

func (m *BuyReply) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *BuyReply) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *BuyReply) GetAvgPrice() float64 {
	if m != nil {
		return m.AvgPrice
	}
	return 0
}

func (m *BuyReply) GetVolume() float64 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *BuyReply) GetFee() float64 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *BuyReply) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *BuyReply) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

type SellRequest struct {
	Code   string    `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
	Otype  OrderType `protobuf:"varint,2,opt,name=otype,proto3,enum=stock.OrderType" json:"otype,omitempty"`
	Volume float64   `protobuf:"fixed64,3,opt,name=volume,proto3" json:"volume,omitempty"`
	Price  float64   `protobuf:"fixed64,4,opt,name=price,proto3" json:"price,omitempty"`
}

func (m *SellRequest) Reset()      { *m = SellRequest{} }
func (*SellRequest) ProtoMessage() {}
func (*SellRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{11}
}
func (m *SellRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SellRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SellRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SellRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SellRequest.Merge(m, src)
}
func (m *SellRequest) XXX_Size() int {
	return m.Size()
}
func (m *SellRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SellRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SellRequest proto.InternalMessageInfo

func (m *SellRequest) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *SellRequest) GetOtype() OrderType {
	if m != nil {
		return m.Otype
	}
	return MarketOrder
}

func (m *SellRequest) GetVolume() float64 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *SellRequest) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

type SellReply struct {
	Id        string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Code      string           `protobuf:"bytes,2,opt,name=code,proto3" json:"code,omitempty"`
	AvgPrice  float64          `protobuf:"fixed64,3,opt,name=avgPrice,proto3" json:"avgPrice,omitempty"`
	Volume    float64          `protobuf:"fixed64,4,opt,name=volume,proto3" json:"volume,omitempty"`
	Fee       float64          `protobuf:"fixed64,5,opt,name=fee,proto3" json:"fee,omitempty"`
	Price     float64          `protobuf:"fixed64,6,opt,name=price,proto3" json:"price,omitempty"`
	CreatedAt *types.Timestamp `protobuf:"bytes,7,opt,name=createdAt,proto3" json:"createdAt,omitempty"`
}

func (m *SellReply) Reset()      { *m = SellReply{} }
func (*SellReply) ProtoMessage() {}
func (*SellReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{12}
}
func (m *SellReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SellReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SellReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SellReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SellReply.Merge(m, src)
}
func (m *SellReply) XXX_Size() int {
	return m.Size()
}
func (m *SellReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SellReply.DiscardUnknown(m)
}

var xxx_messageInfo_SellReply proto.InternalMessageInfo

func (m *SellReply) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *SellReply) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *SellReply) GetAvgPrice() float64 {
	if m != nil {
		return m.AvgPrice
	}
	return 0
}

func (m *SellReply) GetVolume() float64 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *SellReply) GetFee() float64 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *SellReply) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *SellReply) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

type ChartData struct {
	Open   float64          `protobuf:"fixed64,1,opt,name=open,proto3" json:"open,omitempty"`
	High   float64          `protobuf:"fixed64,2,opt,name=high,proto3" json:"high,omitempty"`
	Low    float64          `protobuf:"fixed64,3,opt,name=low,proto3" json:"low,omitempty"`
	Close  float64          `protobuf:"fixed64,4,opt,name=close,proto3" json:"close,omitempty"`
	Volume float64          `protobuf:"fixed64,5,opt,name=volume,proto3" json:"volume,omitempty"`
	Date   *types.Timestamp `protobuf:"bytes,6,opt,name=date,proto3" json:"date,omitempty"`
}

func (m *ChartData) Reset()      { *m = ChartData{} }
func (*ChartData) ProtoMessage() {}
func (*ChartData) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{13}
}
func (m *ChartData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChartData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChartData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChartData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChartData.Merge(m, src)
}
func (m *ChartData) XXX_Size() int {
	return m.Size()
}
func (m *ChartData) XXX_DiscardUnknown() {
	xxx_messageInfo_ChartData.DiscardUnknown(m)
}

var xxx_messageInfo_ChartData proto.InternalMessageInfo

func (m *ChartData) GetOpen() float64 {
	if m != nil {
		return m.Open
	}
	return 0
}

func (m *ChartData) GetHigh() float64 {
	if m != nil {
		return m.High
	}
	return 0
}

func (m *ChartData) GetLow() float64 {
	if m != nil {
		return m.Low
	}
	return 0
}

func (m *ChartData) GetClose() float64 {
	if m != nil {
		return m.Close
	}
	return 0
}

func (m *ChartData) GetVolume() float64 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *ChartData) GetDate() *types.Timestamp {
	if m != nil {
		return m.Date
	}
	return nil
}

type Order struct {
	Id        string           `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Side      Order_Side       `protobuf:"varint,2,opt,name=side,proto3,enum=stock.Order_Side" json:"side,omitempty"`
	Type      OrderType        `protobuf:"varint,3,opt,name=type,proto3,enum=stock.OrderType" json:"type,omitempty"`
	Code      string           `protobuf:"bytes,4,opt,name=code,proto3" json:"code,omitempty"`
	CreatedAt *types.Timestamp `protobuf:"bytes,5,opt,name=createdAt,proto3" json:"createdAt,omitempty"`
	Fee       float64          `protobuf:"fixed64,6,opt,name=fee,proto3" json:"fee,omitempty"`
	State     string           `protobuf:"bytes,7,opt,name=state,proto3" json:"state,omitempty"`
	Volume    float64          `protobuf:"fixed64,8,opt,name=volume,proto3" json:"volume,omitempty"`
	Price     float64          `protobuf:"fixed64,9,opt,name=price,proto3" json:"price,omitempty"`
	//해당 주문에 걸린 체결 수
	TradeCount float64 `protobuf:"fixed64,10,opt,name=tradeCount,proto3" json:"tradeCount,omitempty"`
}

func (m *Order) Reset()      { *m = Order{} }
func (*Order) ProtoMessage() {}
func (*Order) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{14}
}
func (m *Order) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Order) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Order.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Order) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Order.Merge(m, src)
}
func (m *Order) XXX_Size() int {
	return m.Size()
}
func (m *Order) XXX_DiscardUnknown() {
	xxx_messageInfo_Order.DiscardUnknown(m)
}

var xxx_messageInfo_Order proto.InternalMessageInfo

func (m *Order) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Order) GetSide() Order_Side {
	if m != nil {
		return m.Side
	}
	return Ask
}

func (m *Order) GetType() OrderType {
	if m != nil {
		return m.Type
	}
	return MarketOrder
}

func (m *Order) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *Order) GetCreatedAt() *types.Timestamp {
	if m != nil {
		return m.CreatedAt
	}
	return nil
}

func (m *Order) GetFee() float64 {
	if m != nil {
		return m.Fee
	}
	return 0
}

func (m *Order) GetState() string {
	if m != nil {
		return m.State
	}
	return ""
}

func (m *Order) GetVolume() float64 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *Order) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Order) GetTradeCount() float64 {
	if m != nil {
		return m.TradeCount
	}
	return 0
}

type OrderListReply struct {
	Order []*Order `protobuf:"bytes,1,rep,name=order,proto3" json:"order,omitempty"`
}

func (m *OrderListReply) Reset()      { *m = OrderListReply{} }
func (*OrderListReply) ProtoMessage() {}
func (*OrderListReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{15}
}
func (m *OrderListReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderListReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderListReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderListReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderListReply.Merge(m, src)
}
func (m *OrderListReply) XXX_Size() int {
	return m.Size()
}
func (m *OrderListReply) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderListReply.DiscardUnknown(m)
}

var xxx_messageInfo_OrderListReply proto.InternalMessageInfo

func (m *OrderListReply) GetOrder() []*Order {
	if m != nil {
		return m.Order
	}
	return nil
}

type CancelOrderRequest struct {
	Id string `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *CancelOrderRequest) Reset()      { *m = CancelOrderRequest{} }
func (*CancelOrderRequest) ProtoMessage() {}
func (*CancelOrderRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{16}
}
func (m *CancelOrderRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CancelOrderRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CancelOrderRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CancelOrderRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CancelOrderRequest.Merge(m, src)
}
func (m *CancelOrderRequest) XXX_Size() int {
	return m.Size()
}
func (m *CancelOrderRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CancelOrderRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CancelOrderRequest proto.InternalMessageInfo

func (m *CancelOrderRequest) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

type OrderBookStreamRequest struct {
	Codes []string `protobuf:"bytes,1,rep,name=codes,proto3" json:"codes,omitempty"`
}

func (m *OrderBookStreamRequest) Reset()      { *m = OrderBookStreamRequest{} }
func (*OrderBookStreamRequest) ProtoMessage() {}
func (*OrderBookStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{17}
}
func (m *OrderBookStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBookStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBookStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderBookStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBookStreamRequest.Merge(m, src)
}
func (m *OrderBookStreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *OrderBookStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBookStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBookStreamRequest proto.InternalMessageInfo

func (m *OrderBookStreamRequest) GetCodes() []string {
	if m != nil {
		return m.Codes
	}
	return nil
}

type OrderBookStreamReply struct {
}

func (m *OrderBookStreamReply) Reset()      { *m = OrderBookStreamReply{} }
func (*OrderBookStreamReply) ProtoMessage() {}
func (*OrderBookStreamReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{18}
}
func (m *OrderBookStreamReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrderBookStreamReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrderBookStreamReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrderBookStreamReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrderBookStreamReply.Merge(m, src)
}
func (m *OrderBookStreamReply) XXX_Size() int {
	return m.Size()
}
func (m *OrderBookStreamReply) XXX_DiscardUnknown() {
	xxx_messageInfo_OrderBookStreamReply.DiscardUnknown(m)
}

var xxx_messageInfo_OrderBookStreamReply proto.InternalMessageInfo

type TradeStreamRequest struct {
	Codes []string `protobuf:"bytes,1,rep,name=codes,proto3" json:"codes,omitempty"`
}

func (m *TradeStreamRequest) Reset()      { *m = TradeStreamRequest{} }
func (*TradeStreamRequest) ProtoMessage() {}
func (*TradeStreamRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{19}
}
func (m *TradeStreamRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradeStreamRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradeStreamRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradeStreamRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradeStreamRequest.Merge(m, src)
}
func (m *TradeStreamRequest) XXX_Size() int {
	return m.Size()
}
func (m *TradeStreamRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TradeStreamRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TradeStreamRequest proto.InternalMessageInfo

func (m *TradeStreamRequest) GetCodes() []string {
	if m != nil {
		return m.Codes
	}
	return nil
}

type TradeStreamReply struct {
	Code   string           `protobuf:"bytes,1,opt,name=code,proto3" json:"code,omitempty"`
	Price  float64          `protobuf:"fixed64,2,opt,name=price,proto3" json:"price,omitempty"`
	Volume float64          `protobuf:"fixed64,3,opt,name=volume,proto3" json:"volume,omitempty"`
	Date   *types.Timestamp `protobuf:"bytes,4,opt,name=date,proto3" json:"date,omitempty"`
	Askbit string           `protobuf:"bytes,5,opt,name=askbit,proto3" json:"askbit,omitempty"`
}

func (m *TradeStreamReply) Reset()      { *m = TradeStreamReply{} }
func (*TradeStreamReply) ProtoMessage() {}
func (*TradeStreamReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{20}
}
func (m *TradeStreamReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TradeStreamReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TradeStreamReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TradeStreamReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TradeStreamReply.Merge(m, src)
}
func (m *TradeStreamReply) XXX_Size() int {
	return m.Size()
}
func (m *TradeStreamReply) XXX_DiscardUnknown() {
	xxx_messageInfo_TradeStreamReply.DiscardUnknown(m)
}

var xxx_messageInfo_TradeStreamReply proto.InternalMessageInfo

func (m *TradeStreamReply) GetCode() string {
	if m != nil {
		return m.Code
	}
	return ""
}

func (m *TradeStreamReply) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *TradeStreamReply) GetVolume() float64 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *TradeStreamReply) GetDate() *types.Timestamp {
	if m != nil {
		return m.Date
	}
	return nil
}

func (m *TradeStreamReply) GetAskbit() string {
	if m != nil {
		return m.Askbit
	}
	return ""
}

func init() {
	proto.RegisterEnum("stock.OrderType", OrderType_name, OrderType_value)
	proto.RegisterEnum("stock.Order_Side", Order_Side_name, Order_Side_value)
	proto.RegisterType((*AllMarketsReply)(nil), "stock.AllMarketsReply")
	proto.RegisterType((*Account)(nil), "stock.Account")
	proto.RegisterType((*AccountRequest)(nil), "stock.AccountRequest")
	proto.RegisterType((*AccountReply)(nil), "stock.AccountReply")
	proto.RegisterType((*TickRequest)(nil), "stock.TickRequest")
	proto.RegisterType((*TickReply)(nil), "stock.TickReply")
	proto.RegisterType((*ChartRequest)(nil), "stock.ChartRequest")
	proto.RegisterType((*ChartReply)(nil), "stock.ChartReply")
	proto.RegisterType((*AccountsReply)(nil), "stock.AccountsReply")
	proto.RegisterType((*BuyRequest)(nil), "stock.BuyRequest")
	proto.RegisterType((*BuyReply)(nil), "stock.BuyReply")
	proto.RegisterType((*SellRequest)(nil), "stock.SellRequest")
	proto.RegisterType((*SellReply)(nil), "stock.SellReply")
	proto.RegisterType((*ChartData)(nil), "stock.ChartData")
	proto.RegisterType((*Order)(nil), "stock.Order")
	proto.RegisterType((*OrderListReply)(nil), "stock.OrderListReply")
	proto.RegisterType((*CancelOrderRequest)(nil), "stock.CancelOrderRequest")
	proto.RegisterType((*OrderBookStreamRequest)(nil), "stock.OrderBookStreamRequest")
	proto.RegisterType((*OrderBookStreamReply)(nil), "stock.OrderBookStreamReply")
	proto.RegisterType((*TradeStreamRequest)(nil), "stock.TradeStreamRequest")
	proto.RegisterType((*TradeStreamReply)(nil), "stock.TradeStreamReply")
}

func init() { proto.RegisterFile("stock/stock.proto", fileDescriptor_e6b29708bd139bde) }

var fileDescriptor_e6b29708bd139bde = []byte{
	// 1025 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x56, 0xcd, 0x6e, 0xeb, 0x44,
	0x14, 0xf6, 0x24, 0x76, 0x93, 0x9c, 0x94, 0x34, 0x9d, 0xdb, 0x1b, 0x82, 0xaf, 0x30, 0xd5, 0x70,
	0x81, 0x2a, 0xa0, 0x14, 0xca, 0x15, 0x20, 0x40, 0x48, 0x4d, 0xb9, 0xbb, 0xcb, 0x9f, 0xdb, 0x17,
	0x70, 0xe3, 0x69, 0x6a, 0xc5, 0xe9, 0x84, 0x78, 0xd2, 0x2a, 0x3b, 0x1e, 0x81, 0x07, 0x60, 0x81,
	0xc4, 0x86, 0xe7, 0x40, 0x20, 0xb1, 0xec, 0xf2, 0x2e, 0x69, 0xba, 0x61, 0x79, 0x1f, 0x01, 0xcd,
	0x8f, 0x27, 0xe3, 0xa4, 0x81, 0xb2, 0x41, 0x62, 0x63, 0xcd, 0xf9, 0xf1, 0x9c, 0x73, 0xbe, 0xf3,
	0x37, 0xb0, 0x9d, 0x71, 0xd6, 0x1f, 0xee, 0xcb, 0x6f, 0x77, 0x3c, 0x61, 0x9c, 0x61, 0x4f, 0x12,
	0xfe, 0xa3, 0x01, 0x63, 0x83, 0x94, 0xee, 0x4b, 0xe6, 0xe9, 0xf4, 0x6c, 0x9f, 0x8e, 0xc6, 0x7c,
	0xa6, 0x74, 0xfc, 0xd7, 0x96, 0x85, 0x3c, 0x19, 0xd1, 0x8c, 0x47, 0xa3, 0xb1, 0x52, 0x20, 0x6f,
	0xc1, 0xd6, 0x61, 0x9a, 0x7e, 0x11, 0x4d, 0x86, 0x94, 0x67, 0x21, 0x1d, 0xa7, 0x33, 0xbc, 0x03,
	0x5e, 0x9f, 0xc5, 0x34, 0x6b, 0xa3, 0xdd, 0xf2, 0x5e, 0x2d, 0x54, 0x04, 0xb9, 0x82, 0xca, 0x61,
	0xbf, 0xcf, 0xa6, 0x17, 0x1c, 0x63, 0x70, 0x05, 0xaf, 0x8d, 0x76, 0xd1, 0x5e, 0x2d, 0x94, 0x67,
	0xdc, 0x86, 0xca, 0x69, 0x94, 0x46, 0x17, 0x7d, 0xda, 0x2e, 0xed, 0xa2, 0x3d, 0x14, 0xe6, 0x24,
	0x0e, 0x00, 0xa2, 0xcb, 0x41, 0x6f, 0xf6, 0xf5, 0x24, 0xe9, 0xd3, 0x76, 0x59, 0x0a, 0x2d, 0x8e,
	0x90, 0x73, 0xc6, 0xa3, 0x54, 0xc9, 0x5d, 0x25, 0x5f, 0x70, 0x48, 0x07, 0x1a, 0xda, 0x70, 0x48,
	0xbf, 0x9d, 0xd2, 0x8c, 0x0b, 0x5b, 0x91, 0xe2, 0x68, 0x17, 0x72, 0x92, 0x10, 0xd8, 0x34, 0xba,
	0x22, 0x14, 0x0c, 0x6e, 0x72, 0x71, 0xc6, 0x72, 0x4f, 0xc5, 0x99, 0xbc, 0x0e, 0xf5, 0x93, 0xa4,
	0x3f, 0xcc, 0x2f, 0xb3, 0xa2, 0x45, 0x8b, 0x68, 0x13, 0xa8, 0x29, 0x25, 0x0d, 0xc8, 0x58, 0x3a,
	0x87, 0xa4, 0x73, 0x8a, 0xc0, 0x5d, 0x70, 0xe3, 0x88, 0xab, 0x70, 0xeb, 0x07, 0x7e, 0x57, 0x21,
	0xdd, 0xcd, 0x91, 0xee, 0x9e, 0xe4, 0x48, 0x87, 0x52, 0x0f, 0xb7, 0x60, 0xe3, 0x92, 0xa5, 0xd3,
	0x51, 0x8e, 0x81, 0xa6, 0xc8, 0x97, 0xb0, 0x79, 0x74, 0x1e, 0x4d, 0x4c, 0x74, 0x77, 0xa1, 0xdb,
	0x81, 0x12, 0x67, 0xf7, 0xb0, 0x54, 0xe2, 0x8c, 0x1c, 0x00, 0xe8, 0xfb, 0x84, 0xef, 0x8f, 0xa5,
	0x97, 0x91, 0xcc, 0x65, 0xfd, 0xa0, 0xd9, 0x55, 0x05, 0x24, 0x15, 0x3e, 0x8f, 0x78, 0x24, 0x7d,
	0x8b, 0xc8, 0x27, 0xf0, 0x92, 0xc6, 0x4d, 0xd7, 0x40, 0x07, 0xaa, 0x1a, 0xd3, 0x4c, 0xff, 0xda,
	0xd0, 0xbf, 0xe6, 0xf8, 0x1a, 0x39, 0xb9, 0x04, 0xe8, 0x4d, 0x67, 0x7f, 0xe7, 0xfe, 0x9b, 0xe0,
	0x31, 0x3e, 0x1b, 0x2b, 0xac, 0x1a, 0xc6, 0x8b, 0xaf, 0x26, 0x31, 0x9d, 0x9c, 0xcc, 0xc6, 0x34,
	0x54, 0xe2, 0x75, 0x10, 0x2d, 0x12, 0xe0, 0x5a, 0x09, 0x20, 0xbf, 0x22, 0xa8, 0x4a, 0xc3, 0xc2,
	0xe1, 0x06, 0x94, 0x92, 0x58, 0x1b, 0x2d, 0x25, 0xb1, 0x71, 0xa3, 0x64, 0xb9, 0xe1, 0x43, 0x35,
	0xba, 0x1c, 0xd8, 0x75, 0x68, 0x68, 0xcb, 0xb4, 0x5b, 0x30, 0xdd, 0x84, 0xf2, 0x19, 0xa5, 0x6d,
	0x4f, 0x32, 0xc5, 0x71, 0xe1, 0xcc, 0x86, 0x5d, 0x0d, 0x1f, 0x41, 0xad, 0x3f, 0xa1, 0x11, 0xa7,
	0xf1, 0x21, 0x6f, 0x57, 0xfe, 0x31, 0x51, 0x0b, 0x65, 0x72, 0x05, 0xf5, 0x63, 0x9a, 0xa6, 0xff,
	0x3d, 0x7e, 0xbf, 0x21, 0xa8, 0x29, 0xcb, 0xff, 0x6f, 0x00, 0x7f, 0x42, 0x50, 0x33, 0x05, 0x2d,
	0xfc, 0x66, 0x63, 0x7a, 0xa1, 0x7b, 0x55, 0x9e, 0x05, 0xef, 0x3c, 0x19, 0x9c, 0xeb, 0xc9, 0x24,
	0xcf, 0xc2, 0xaf, 0x94, 0x5d, 0xe9, 0x30, 0xc4, 0x51, 0x4e, 0x82, 0x94, 0x65, 0x06, 0x25, 0x49,
	0x58, 0x71, 0x79, 0x85, 0xb8, 0xf2, 0xf6, 0xdf, 0xb8, 0x5f, 0xfb, 0x93, 0x5f, 0x4a, 0xe0, 0xc9,
	0x84, 0xad, 0x20, 0xfd, 0x06, 0xb8, 0x59, 0x12, 0xe7, 0xc9, 0xdd, 0xb6, 0x93, 0xdb, 0x3d, 0x4e,
	0x62, 0x1a, 0x4a, 0xb1, 0xe8, 0x64, 0x59, 0x03, 0xe5, 0x35, 0x35, 0x20, 0xa5, 0x26, 0x6d, 0xae,
	0x95, 0xb6, 0x02, 0xb4, 0xde, 0xbf, 0x80, 0x36, 0x4f, 0xde, 0x46, 0x21, 0x79, 0x19, 0x17, 0x71,
	0x57, 0xd4, 0xb8, 0x94, 0x84, 0x05, 0x52, 0xf5, 0xee, 0xc2, 0xab, 0xd9, 0xa9, 0x16, 0x13, 0x7f,
	0x12, 0xc5, 0xf4, 0x48, 0x8e, 0x70, 0xd0, 0x13, 0xdf, 0x70, 0x48, 0x1b, 0x5c, 0x11, 0x37, 0xae,
	0x40, 0xf9, 0x30, 0x1b, 0x36, 0x1d, 0x71, 0xe8, 0x25, 0x71, 0x13, 0x91, 0x27, 0xd0, 0x90, 0x01,
	0x3f, 0x4b, 0x32, 0x3d, 0xdf, 0x08, 0x78, 0x4c, 0x70, 0xf4, 0x94, 0xda, 0xb4, 0x61, 0x09, 0x95,
	0x88, 0x3c, 0x06, 0x7c, 0x24, 0x56, 0x51, 0xaa, 0xb8, 0xba, 0xd1, 0x96, 0xd2, 0x40, 0xba, 0xd0,
	0x92, 0xf2, 0x1e, 0x63, 0xc3, 0x63, 0x3e, 0xa1, 0xd1, 0xe8, 0x8e, 0x15, 0x61, 0x2d, 0xc4, 0x16,
	0xec, 0xac, 0xe8, 0x8f, 0xd3, 0x19, 0xe9, 0x00, 0x3e, 0x11, 0xb1, 0xdc, 0xe7, 0x8e, 0x1f, 0x10,
	0x34, 0x0b, 0xca, 0x7a, 0x69, 0xad, 0x4c, 0x00, 0x03, 0x64, 0xc9, 0x06, 0x72, 0x5d, 0xbf, 0xe7,
	0xb5, 0xe9, 0xde, 0x7f, 0x35, 0x45, 0xd9, 0xf0, 0x34, 0x51, 0xd5, 0x51, 0x0b, 0x35, 0xd5, 0x79,
	0x07, 0x6a, 0xa6, 0xbe, 0xf0, 0x16, 0xd4, 0xd5, 0x33, 0x41, 0xb2, 0x9a, 0x0e, 0x6e, 0x00, 0x3c,
	0x4b, 0x46, 0x89, 0xa6, 0xd1, 0xc1, 0x8f, 0x1e, 0x78, 0xc7, 0x02, 0x7d, 0xfc, 0x19, 0xc0, 0xe2,
	0x51, 0x81, 0x5b, 0x2b, 0xf6, 0x9f, 0x8a, 0x17, 0x8a, 0xdf, 0xca, 0x37, 0x4a, 0xf1, 0xfd, 0x41,
	0x1c, 0xfc, 0xe1, 0xe2, 0xad, 0xf1, 0x70, 0x69, 0xed, 0x28, 0x38, 0xfd, 0x07, 0xcb, 0x6c, 0xf5,
	0xe3, 0x07, 0x00, 0x62, 0x6d, 0x2b, 0x34, 0x31, 0xd6, 0x4a, 0xd6, 0xba, 0xf7, 0x9b, 0x05, 0x9e,
	0xfc, 0xeb, 0x5d, 0x84, 0xdf, 0x03, 0x4f, 0x4e, 0x10, 0xfc, 0xc0, 0x5e, 0x90, 0xf9, 0x3f, 0xdb,
	0x45, 0xa6, 0x32, 0xf5, 0x31, 0x54, 0xf3, 0x95, 0xb9, 0x36, 0xc2, 0x9d, 0xa2, 0x97, 0x26, 0xbe,
	0xb7, 0xa1, 0xdc, 0x9b, 0xce, 0x70, 0x7e, 0xef, 0x62, 0x7b, 0xfa, 0x5b, 0x36, 0x4b, 0x29, 0x77,
	0xc1, 0x15, 0x53, 0xda, 0x44, 0x63, 0x2d, 0x0b, 0x13, 0x8d, 0x19, 0xe3, 0xc4, 0xc1, 0x9f, 0xea,
	0xa4, 0x89, 0x1e, 0x59, 0xeb, 0xd9, 0x43, 0xbb, 0x4f, 0x4c, 0x37, 0x11, 0x07, 0xf7, 0xa0, 0x6e,
	0xf5, 0x0a, 0x7e, 0x25, 0x0f, 0x7d, 0xa5, 0x7f, 0xfc, 0x35, 0x57, 0x13, 0x07, 0x3f, 0x85, 0xba,
	0x55, 0xd4, 0xe6, 0x8e, 0xd5, 0xae, 0xf0, 0x5f, 0xbe, 0x4b, 0x94, 0x27, 0xe5, 0x1b, 0xd8, 0x5a,
	0x6a, 0x30, 0xfc, 0xaa, 0xed, 0xf6, 0x4a, 0xa3, 0xfa, 0x8f, 0xd6, 0x89, 0xf5, 0x95, 0xbd, 0x27,
	0xd7, 0x37, 0x81, 0xf3, 0xfc, 0x26, 0x70, 0x5e, 0xdc, 0x04, 0xe8, 0xbb, 0x79, 0x80, 0x7e, 0x9e,
	0x07, 0xe8, 0xf7, 0x79, 0x80, 0xae, 0xe7, 0x01, 0xfa, 0x63, 0x1e, 0xa0, 0x3f, 0xe7, 0x81, 0xf3,
	0x62, 0x1e, 0xa0, 0xef, 0x6f, 0x03, 0xe7, 0xfa, 0x36, 0x70, 0x9e, 0xdf, 0x06, 0xce, 0xe9, 0x86,
	0x8c, 0xf0, 0xfd, 0xbf, 0x02, 0x00, 0x00, 0xff, 0xff, 0x47, 0xcc, 0x78, 0xc1, 0x84, 0x0b, 0x00,
	0x00,
}

func (x OrderType) String() string {
	s, ok := OrderType_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (x Order_Side) String() string {
	s, ok := Order_Side_name[int32(x)]
	if ok {
		return s
	}
	return strconv.Itoa(int(x))
}
func (this *AllMarketsReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AllMarketsReply)
	if !ok {
		that2, ok := that.(AllMarketsReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Codes) != len(that1.Codes) {
		return false
	}
	for i := range this.Codes {
		if this.Codes[i] != that1.Codes[i] {
			return false
		}
	}
	return true
}
func (this *Account) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Account)
	if !ok {
		that2, ok := that.(Account)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Balance != that1.Balance {
		return false
	}
	if this.AvgByPrice != that1.AvgByPrice {
		return false
	}
	if this.TotalPrice != that1.TotalPrice {
		return false
	}
	return true
}
func (this *AccountRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccountRequest)
	if !ok {
		that2, ok := that.(AccountRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Account != that1.Account {
		return false
	}
	return true
}
func (this *AccountReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccountReply)
	if !ok {
		that2, ok := that.(AccountReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Info != that1.Info {
		return false
	}
	return true
}
func (this *TickRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TickRequest)
	if !ok {
		that2, ok := that.(TickRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Codes != that1.Codes {
		return false
	}
	return true
}
func (this *TickReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TickReply)
	if !ok {
		that2, ok := that.(TickReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Price != that1.Price {
		return false
	}
	if !this.Date.Equal(that1.Date) {
		return false
	}
	if this.Volume != that1.Volume {
		return false
	}
	return true
}
func (this *ChartRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChartRequest)
	if !ok {
		that2, ok := that.(ChartRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if !this.To.Equal(that1.To) {
		return false
	}
	return true
}
func (this *ChartReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChartReply)
	if !ok {
		that2, ok := that.(ChartReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Data) != len(that1.Data) {
		return false
	}
	for i := range this.Data {
		if !this.Data[i].Equal(that1.Data[i]) {
			return false
		}
	}
	return true
}
func (this *AccountsReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*AccountsReply)
	if !ok {
		that2, ok := that.(AccountsReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Accounts) != len(that1.Accounts) {
		return false
	}
	for i := range this.Accounts {
		if !this.Accounts[i].Equal(that1.Accounts[i]) {
			return false
		}
	}
	return true
}
func (this *BuyRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BuyRequest)
	if !ok {
		that2, ok := that.(BuyRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Otype != that1.Otype {
		return false
	}
	if this.Volume != that1.Volume {
		return false
	}
	if this.Price != that1.Price {
		return false
	}
	return true
}
func (this *BuyReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*BuyReply)
	if !ok {
		that2, ok := that.(BuyReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.AvgPrice != that1.AvgPrice {
		return false
	}
	if this.Volume != that1.Volume {
		return false
	}
	if this.Fee != that1.Fee {
		return false
	}
	if this.Price != that1.Price {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	return true
}
func (this *SellRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SellRequest)
	if !ok {
		that2, ok := that.(SellRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Otype != that1.Otype {
		return false
	}
	if this.Volume != that1.Volume {
		return false
	}
	if this.Price != that1.Price {
		return false
	}
	return true
}
func (this *SellReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*SellReply)
	if !ok {
		that2, ok := that.(SellReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.AvgPrice != that1.AvgPrice {
		return false
	}
	if this.Volume != that1.Volume {
		return false
	}
	if this.Fee != that1.Fee {
		return false
	}
	if this.Price != that1.Price {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	return true
}
func (this *ChartData) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*ChartData)
	if !ok {
		that2, ok := that.(ChartData)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Open != that1.Open {
		return false
	}
	if this.High != that1.High {
		return false
	}
	if this.Low != that1.Low {
		return false
	}
	if this.Close != that1.Close {
		return false
	}
	if this.Volume != that1.Volume {
		return false
	}
	if !this.Date.Equal(that1.Date) {
		return false
	}
	return true
}
func (this *Order) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*Order)
	if !ok {
		that2, ok := that.(Order)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	if this.Side != that1.Side {
		return false
	}
	if this.Type != that1.Type {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if !this.CreatedAt.Equal(that1.CreatedAt) {
		return false
	}
	if this.Fee != that1.Fee {
		return false
	}
	if this.State != that1.State {
		return false
	}
	if this.Volume != that1.Volume {
		return false
	}
	if this.Price != that1.Price {
		return false
	}
	if this.TradeCount != that1.TradeCount {
		return false
	}
	return true
}
func (this *OrderListReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderListReply)
	if !ok {
		that2, ok := that.(OrderListReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Order) != len(that1.Order) {
		return false
	}
	for i := range this.Order {
		if !this.Order[i].Equal(that1.Order[i]) {
			return false
		}
	}
	return true
}
func (this *CancelOrderRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*CancelOrderRequest)
	if !ok {
		that2, ok := that.(CancelOrderRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Id != that1.Id {
		return false
	}
	return true
}
func (this *OrderBookStreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderBookStreamRequest)
	if !ok {
		that2, ok := that.(OrderBookStreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Codes) != len(that1.Codes) {
		return false
	}
	for i := range this.Codes {
		if this.Codes[i] != that1.Codes[i] {
			return false
		}
	}
	return true
}
func (this *OrderBookStreamReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*OrderBookStreamReply)
	if !ok {
		that2, ok := that.(OrderBookStreamReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	return true
}
func (this *TradeStreamRequest) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TradeStreamRequest)
	if !ok {
		that2, ok := that.(TradeStreamRequest)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if len(this.Codes) != len(that1.Codes) {
		return false
	}
	for i := range this.Codes {
		if this.Codes[i] != that1.Codes[i] {
			return false
		}
	}
	return true
}
func (this *TradeStreamReply) Equal(that interface{}) bool {
	if that == nil {
		return this == nil
	}

	that1, ok := that.(*TradeStreamReply)
	if !ok {
		that2, ok := that.(TradeStreamReply)
		if ok {
			that1 = &that2
		} else {
			return false
		}
	}
	if that1 == nil {
		return this == nil
	} else if this == nil {
		return false
	}
	if this.Code != that1.Code {
		return false
	}
	if this.Price != that1.Price {
		return false
	}
	if this.Volume != that1.Volume {
		return false
	}
	if !this.Date.Equal(that1.Date) {
		return false
	}
	if this.Askbit != that1.Askbit {
		return false
	}
	return true
}
func (this *AllMarketsReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&stock.AllMarketsReply{")
	s = append(s, "Codes: "+fmt.Sprintf("%#v", this.Codes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Account) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&stock.Account{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Balance: "+fmt.Sprintf("%#v", this.Balance)+",\n")
	s = append(s, "AvgByPrice: "+fmt.Sprintf("%#v", this.AvgByPrice)+",\n")
	s = append(s, "TotalPrice: "+fmt.Sprintf("%#v", this.TotalPrice)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AccountRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&stock.AccountRequest{")
	s = append(s, "Account: "+fmt.Sprintf("%#v", this.Account)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AccountReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&stock.AccountReply{")
	s = append(s, "Info: "+fmt.Sprintf("%#v", this.Info)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TickRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&stock.TickRequest{")
	s = append(s, "Codes: "+fmt.Sprintf("%#v", this.Codes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TickReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&stock.TickReply{")
	s = append(s, "Price: "+fmt.Sprintf("%#v", this.Price)+",\n")
	if this.Date != nil {
		s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	}
	s = append(s, "Volume: "+fmt.Sprintf("%#v", this.Volume)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ChartRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&stock.ChartRequest{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	if this.To != nil {
		s = append(s, "To: "+fmt.Sprintf("%#v", this.To)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ChartReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&stock.ChartReply{")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AccountsReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&stock.AccountsReply{")
	if this.Accounts != nil {
		s = append(s, "Accounts: "+fmt.Sprintf("%#v", this.Accounts)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BuyRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&stock.BuyRequest{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Otype: "+fmt.Sprintf("%#v", this.Otype)+",\n")
	s = append(s, "Volume: "+fmt.Sprintf("%#v", this.Volume)+",\n")
	s = append(s, "Price: "+fmt.Sprintf("%#v", this.Price)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *BuyReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&stock.BuyReply{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "AvgPrice: "+fmt.Sprintf("%#v", this.AvgPrice)+",\n")
	s = append(s, "Volume: "+fmt.Sprintf("%#v", this.Volume)+",\n")
	s = append(s, "Fee: "+fmt.Sprintf("%#v", this.Fee)+",\n")
	s = append(s, "Price: "+fmt.Sprintf("%#v", this.Price)+",\n")
	if this.CreatedAt != nil {
		s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SellRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&stock.SellRequest{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Otype: "+fmt.Sprintf("%#v", this.Otype)+",\n")
	s = append(s, "Volume: "+fmt.Sprintf("%#v", this.Volume)+",\n")
	s = append(s, "Price: "+fmt.Sprintf("%#v", this.Price)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *SellReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 11)
	s = append(s, "&stock.SellReply{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "AvgPrice: "+fmt.Sprintf("%#v", this.AvgPrice)+",\n")
	s = append(s, "Volume: "+fmt.Sprintf("%#v", this.Volume)+",\n")
	s = append(s, "Fee: "+fmt.Sprintf("%#v", this.Fee)+",\n")
	s = append(s, "Price: "+fmt.Sprintf("%#v", this.Price)+",\n")
	if this.CreatedAt != nil {
		s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *ChartData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 10)
	s = append(s, "&stock.ChartData{")
	s = append(s, "Open: "+fmt.Sprintf("%#v", this.Open)+",\n")
	s = append(s, "High: "+fmt.Sprintf("%#v", this.High)+",\n")
	s = append(s, "Low: "+fmt.Sprintf("%#v", this.Low)+",\n")
	s = append(s, "Close: "+fmt.Sprintf("%#v", this.Close)+",\n")
	s = append(s, "Volume: "+fmt.Sprintf("%#v", this.Volume)+",\n")
	if this.Date != nil {
		s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Order) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 14)
	s = append(s, "&stock.Order{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "Side: "+fmt.Sprintf("%#v", this.Side)+",\n")
	s = append(s, "Type: "+fmt.Sprintf("%#v", this.Type)+",\n")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	if this.CreatedAt != nil {
		s = append(s, "CreatedAt: "+fmt.Sprintf("%#v", this.CreatedAt)+",\n")
	}
	s = append(s, "Fee: "+fmt.Sprintf("%#v", this.Fee)+",\n")
	s = append(s, "State: "+fmt.Sprintf("%#v", this.State)+",\n")
	s = append(s, "Volume: "+fmt.Sprintf("%#v", this.Volume)+",\n")
	s = append(s, "Price: "+fmt.Sprintf("%#v", this.Price)+",\n")
	s = append(s, "TradeCount: "+fmt.Sprintf("%#v", this.TradeCount)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderListReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&stock.OrderListReply{")
	if this.Order != nil {
		s = append(s, "Order: "+fmt.Sprintf("%#v", this.Order)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *CancelOrderRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&stock.CancelOrderRequest{")
	s = append(s, "Id: "+fmt.Sprintf("%#v", this.Id)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderBookStreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&stock.OrderBookStreamRequest{")
	s = append(s, "Codes: "+fmt.Sprintf("%#v", this.Codes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *OrderBookStreamReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 4)
	s = append(s, "&stock.OrderBookStreamReply{")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TradeStreamRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&stock.TradeStreamRequest{")
	s = append(s, "Codes: "+fmt.Sprintf("%#v", this.Codes)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TradeStreamReply) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&stock.TradeStreamReply{")
	s = append(s, "Code: "+fmt.Sprintf("%#v", this.Code)+",\n")
	s = append(s, "Price: "+fmt.Sprintf("%#v", this.Price)+",\n")
	s = append(s, "Volume: "+fmt.Sprintf("%#v", this.Volume)+",\n")
	if this.Date != nil {
		s = append(s, "Date: "+fmt.Sprintf("%#v", this.Date)+",\n")
	}
	s = append(s, "Askbit: "+fmt.Sprintf("%#v", this.Askbit)+",\n")
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringStock(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// StockClient is the client API for Stock service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StockClient interface {
	AllMarkets(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*AllMarketsReply, error)
	//특정 소유하고 있는 주식,코인 정보
	Account(ctx context.Context, in *AccountRequest, opts ...grpc.CallOption) (*AccountReply, error)
	TickStream(ctx context.Context, in *TickRequest, opts ...grpc.CallOption) (Stock_TickStreamClient, error)
	Chart(ctx context.Context, in *ChartRequest, opts ...grpc.CallOption) (*ChartReply, error)
	//모든 소유하고 있는 주식, 코인정보
	Accounts(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*AccountsReply, error)
	Buy(ctx context.Context, in *BuyRequest, opts ...grpc.CallOption) (*BuyReply, error)
	Sell(ctx context.Context, in *SellRequest, opts ...grpc.CallOption) (*SellReply, error)
	OrderList(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*OrderListReply, error)
	CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*types.Empty, error)
	TradeStream(ctx context.Context, in *TradeStreamRequest, opts ...grpc.CallOption) (Stock_TradeStreamClient, error)
	OrderBookStream(ctx context.Context, in *OrderBookStreamRequest, opts ...grpc.CallOption) (Stock_OrderBookStreamClient, error)
}

type stockClient struct {
	cc *grpc.ClientConn
}

func NewStockClient(cc *grpc.ClientConn) StockClient {
	return &stockClient{cc}
}

func (c *stockClient) AllMarkets(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*AllMarketsReply, error) {
	out := new(AllMarketsReply)
	err := c.cc.Invoke(ctx, "/stock.Stock/AllMarkets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) Account(ctx context.Context, in *AccountRequest, opts ...grpc.CallOption) (*AccountReply, error) {
	out := new(AccountReply)
	err := c.cc.Invoke(ctx, "/stock.Stock/Account", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) TickStream(ctx context.Context, in *TickRequest, opts ...grpc.CallOption) (Stock_TickStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Stock_serviceDesc.Streams[0], "/stock.Stock/TickStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &stockTickStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Stock_TickStreamClient interface {
	Recv() (*TickReply, error)
	grpc.ClientStream
}

type stockTickStreamClient struct {
	grpc.ClientStream
}

func (x *stockTickStreamClient) Recv() (*TickReply, error) {
	m := new(TickReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *stockClient) Chart(ctx context.Context, in *ChartRequest, opts ...grpc.CallOption) (*ChartReply, error) {
	out := new(ChartReply)
	err := c.cc.Invoke(ctx, "/stock.Stock/Chart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) Accounts(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*AccountsReply, error) {
	out := new(AccountsReply)
	err := c.cc.Invoke(ctx, "/stock.Stock/Accounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) Buy(ctx context.Context, in *BuyRequest, opts ...grpc.CallOption) (*BuyReply, error) {
	out := new(BuyReply)
	err := c.cc.Invoke(ctx, "/stock.Stock/Buy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) Sell(ctx context.Context, in *SellRequest, opts ...grpc.CallOption) (*SellReply, error) {
	out := new(SellReply)
	err := c.cc.Invoke(ctx, "/stock.Stock/Sell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) OrderList(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*OrderListReply, error) {
	out := new(OrderListReply)
	err := c.cc.Invoke(ctx, "/stock.Stock/OrderList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*types.Empty, error) {
	out := new(types.Empty)
	err := c.cc.Invoke(ctx, "/stock.Stock/CancelOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) TradeStream(ctx context.Context, in *TradeStreamRequest, opts ...grpc.CallOption) (Stock_TradeStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Stock_serviceDesc.Streams[1], "/stock.Stock/TradeStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &stockTradeStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Stock_TradeStreamClient interface {
	Recv() (*TradeStreamReply, error)
	grpc.ClientStream
}

type stockTradeStreamClient struct {
	grpc.ClientStream
}

func (x *stockTradeStreamClient) Recv() (*TradeStreamReply, error) {
	m := new(TradeStreamReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *stockClient) OrderBookStream(ctx context.Context, in *OrderBookStreamRequest, opts ...grpc.CallOption) (Stock_OrderBookStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Stock_serviceDesc.Streams[2], "/stock.Stock/OrderBookStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &stockOrderBookStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Stock_OrderBookStreamClient interface {
	Recv() (*OrderBookStreamReply, error)
	grpc.ClientStream
}

type stockOrderBookStreamClient struct {
	grpc.ClientStream
}

func (x *stockOrderBookStreamClient) Recv() (*OrderBookStreamReply, error) {
	m := new(OrderBookStreamReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StockServer is the server API for Stock service.
type StockServer interface {
	AllMarkets(context.Context, *types.Empty) (*AllMarketsReply, error)
	//특정 소유하고 있는 주식,코인 정보
	Account(context.Context, *AccountRequest) (*AccountReply, error)
	TickStream(*TickRequest, Stock_TickStreamServer) error
	Chart(context.Context, *ChartRequest) (*ChartReply, error)
	//모든 소유하고 있는 주식, 코인정보
	Accounts(context.Context, *types.Empty) (*AccountsReply, error)
	Buy(context.Context, *BuyRequest) (*BuyReply, error)
	Sell(context.Context, *SellRequest) (*SellReply, error)
	OrderList(context.Context, *types.Empty) (*OrderListReply, error)
	CancelOrder(context.Context, *CancelOrderRequest) (*types.Empty, error)
	TradeStream(*TradeStreamRequest, Stock_TradeStreamServer) error
	OrderBookStream(*OrderBookStreamRequest, Stock_OrderBookStreamServer) error
}

// UnimplementedStockServer can be embedded to have forward compatible implementations.
type UnimplementedStockServer struct {
}

func (*UnimplementedStockServer) AllMarkets(ctx context.Context, req *types.Empty) (*AllMarketsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllMarkets not implemented")
}
func (*UnimplementedStockServer) Account(ctx context.Context, req *AccountRequest) (*AccountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Account not implemented")
}
func (*UnimplementedStockServer) TickStream(req *TickRequest, srv Stock_TickStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method TickStream not implemented")
}
func (*UnimplementedStockServer) Chart(ctx context.Context, req *ChartRequest) (*ChartReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chart not implemented")
}
func (*UnimplementedStockServer) Accounts(ctx context.Context, req *types.Empty) (*AccountsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Accounts not implemented")
}
func (*UnimplementedStockServer) Buy(ctx context.Context, req *BuyRequest) (*BuyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Buy not implemented")
}
func (*UnimplementedStockServer) Sell(ctx context.Context, req *SellRequest) (*SellReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sell not implemented")
}
func (*UnimplementedStockServer) OrderList(ctx context.Context, req *types.Empty) (*OrderListReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderList not implemented")
}
func (*UnimplementedStockServer) CancelOrder(ctx context.Context, req *CancelOrderRequest) (*types.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelOrder not implemented")
}
func (*UnimplementedStockServer) TradeStream(req *TradeStreamRequest, srv Stock_TradeStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method TradeStream not implemented")
}
func (*UnimplementedStockServer) OrderBookStream(req *OrderBookStreamRequest, srv Stock_OrderBookStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method OrderBookStream not implemented")
}

func RegisterStockServer(s *grpc.Server, srv StockServer) {
	s.RegisterService(&_Stock_serviceDesc, srv)
}

func _Stock_AllMarkets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).AllMarkets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stock.Stock/AllMarkets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).AllMarkets(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_Account_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).Account(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stock.Stock/Account",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).Account(ctx, req.(*AccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_TickStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TickRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StockServer).TickStream(m, &stockTickStreamServer{stream})
}

type Stock_TickStreamServer interface {
	Send(*TickReply) error
	grpc.ServerStream
}

type stockTickStreamServer struct {
	grpc.ServerStream
}

func (x *stockTickStreamServer) Send(m *TickReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Stock_Chart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).Chart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stock.Stock/Chart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).Chart(ctx, req.(*ChartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_Accounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).Accounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stock.Stock/Accounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).Accounts(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_Buy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).Buy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stock.Stock/Buy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).Buy(ctx, req.(*BuyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_Sell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).Sell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stock.Stock/Sell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).Sell(ctx, req.(*SellRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_OrderList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).OrderList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stock.Stock/OrderList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).OrderList(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_CancelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).CancelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stock.Stock/CancelOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).CancelOrder(ctx, req.(*CancelOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_TradeStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TradeStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StockServer).TradeStream(m, &stockTradeStreamServer{stream})
}

type Stock_TradeStreamServer interface {
	Send(*TradeStreamReply) error
	grpc.ServerStream
}

type stockTradeStreamServer struct {
	grpc.ServerStream
}

func (x *stockTradeStreamServer) Send(m *TradeStreamReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Stock_OrderBookStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OrderBookStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StockServer).OrderBookStream(m, &stockOrderBookStreamServer{stream})
}

type Stock_OrderBookStreamServer interface {
	Send(*OrderBookStreamReply) error
	grpc.ServerStream
}

type stockOrderBookStreamServer struct {
	grpc.ServerStream
}

func (x *stockOrderBookStreamServer) Send(m *OrderBookStreamReply) error {
	return x.ServerStream.SendMsg(m)
}

var _Stock_serviceDesc = grpc.ServiceDesc{
	ServiceName: "stock.Stock",
	HandlerType: (*StockServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AllMarkets",
			Handler:    _Stock_AllMarkets_Handler,
		},
		{
			MethodName: "Account",
			Handler:    _Stock_Account_Handler,
		},
		{
			MethodName: "Chart",
			Handler:    _Stock_Chart_Handler,
		},
		{
			MethodName: "Accounts",
			Handler:    _Stock_Accounts_Handler,
		},
		{
			MethodName: "Buy",
			Handler:    _Stock_Buy_Handler,
		},
		{
			MethodName: "Sell",
			Handler:    _Stock_Sell_Handler,
		},
		{
			MethodName: "OrderList",
			Handler:    _Stock_OrderList_Handler,
		},
		{
			MethodName: "CancelOrder",
			Handler:    _Stock_CancelOrder_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TickStream",
			Handler:       _Stock_TickStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TradeStream",
			Handler:       _Stock_TradeStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "OrderBookStream",
			Handler:       _Stock_OrderBookStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "stock/stock.proto",
}

func (m *AllMarketsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllMarketsReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AllMarketsReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Codes) > 0 {
		for iNdEx := len(m.Codes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Codes[iNdEx])
			copy(dAtA[i:], m.Codes[iNdEx])
			i = encodeVarintStock(dAtA, i, uint64(len(m.Codes[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Account) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Account) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Account) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TotalPrice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TotalPrice))))
		i--
		dAtA[i] = 0x21
	}
	if m.AvgByPrice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AvgByPrice))))
		i--
		dAtA[i] = 0x19
	}
	if m.Balance != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Balance))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Info) > 0 {
		i -= len(m.Info)
		copy(dAtA[i:], m.Info)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Info)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TickRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TickRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TickRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Codes) > 0 {
		i -= len(m.Codes)
		copy(dAtA[i:], m.Codes)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Codes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TickReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TickReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TickReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Volume != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Volume))))
		i--
		dAtA[i] = 0x19
	}
	if m.Date != nil {
		{
			size, err := m.Date.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Price != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *ChartRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChartRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChartRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.To != nil {
		{
			size, err := m.To.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChartReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChartReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChartReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStock(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AccountsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountsReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountsReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Accounts) > 0 {
		for iNdEx := len(m.Accounts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Accounts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStock(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BuyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Price != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i--
		dAtA[i] = 0x21
	}
	if m.Volume != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Volume))))
		i--
		dAtA[i] = 0x19
	}
	if m.Otype != 0 {
		i = encodeVarintStock(dAtA, i, uint64(m.Otype))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BuyReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuyReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Price != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i--
		dAtA[i] = 0x31
	}
	if m.Fee != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Fee))))
		i--
		dAtA[i] = 0x29
	}
	if m.Volume != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Volume))))
		i--
		dAtA[i] = 0x21
	}
	if m.AvgPrice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AvgPrice))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SellRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SellRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SellRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Price != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i--
		dAtA[i] = 0x21
	}
	if m.Volume != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Volume))))
		i--
		dAtA[i] = 0x19
	}
	if m.Otype != 0 {
		i = encodeVarintStock(dAtA, i, uint64(m.Otype))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SellReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SellReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SellReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.Price != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i--
		dAtA[i] = 0x31
	}
	if m.Fee != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Fee))))
		i--
		dAtA[i] = 0x29
	}
	if m.Volume != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Volume))))
		i--
		dAtA[i] = 0x21
	}
	if m.AvgPrice != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.AvgPrice))))
		i--
		dAtA[i] = 0x19
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChartData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChartData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChartData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Date != nil {
		{
			size, err := m.Date.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Volume != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Volume))))
		i--
		dAtA[i] = 0x29
	}
	if m.Close != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Close))))
		i--
		dAtA[i] = 0x21
	}
	if m.Low != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Low))))
		i--
		dAtA[i] = 0x19
	}
	if m.High != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.High))))
		i--
		dAtA[i] = 0x11
	}
	if m.Open != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Open))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *Order) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Order) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Order) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TradeCount != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.TradeCount))))
		i--
		dAtA[i] = 0x51
	}
	if m.Price != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i--
		dAtA[i] = 0x49
	}
	if m.Volume != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Volume))))
		i--
		dAtA[i] = 0x41
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintStock(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Fee != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Fee))))
		i--
		dAtA[i] = 0x31
	}
	if m.CreatedAt != nil {
		{
			size, err := m.CreatedAt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintStock(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Side != 0 {
		i = encodeVarintStock(dAtA, i, uint64(m.Side))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrderListReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderListReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderListReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Order) > 0 {
		for iNdEx := len(m.Order) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Order[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStock(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CancelOrderRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CancelOrderRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CancelOrderRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrderBookStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBookStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderBookStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Codes) > 0 {
		for iNdEx := len(m.Codes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Codes[iNdEx])
			copy(dAtA[i:], m.Codes[iNdEx])
			i = encodeVarintStock(dAtA, i, uint64(len(m.Codes[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *OrderBookStreamReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrderBookStreamReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrderBookStreamReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *TradeStreamRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradeStreamRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradeStreamRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Codes) > 0 {
		for iNdEx := len(m.Codes) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Codes[iNdEx])
			copy(dAtA[i:], m.Codes[iNdEx])
			i = encodeVarintStock(dAtA, i, uint64(len(m.Codes[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TradeStreamReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TradeStreamReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TradeStreamReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Askbit) > 0 {
		i -= len(m.Askbit)
		copy(dAtA[i:], m.Askbit)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Askbit)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Date != nil {
		{
			size, err := m.Date.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Volume != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Volume))))
		i--
		dAtA[i] = 0x19
	}
	if m.Price != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i--
		dAtA[i] = 0x11
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintStock(dAtA []byte, offset int, v uint64) int {
	offset -= sovStock(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AllMarketsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Codes) > 0 {
		for _, s := range m.Codes {
			l = len(s)
			n += 1 + l + sovStock(uint64(l))
		}
	}
	return n
}

func (m *Account) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	if m.Balance != 0 {
		n += 9
	}
	if m.AvgByPrice != 0 {
		n += 9
	}
	if m.TotalPrice != 0 {
		n += 9
	}
	return n
}

func (m *AccountRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	return n
}

func (m *AccountReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	return n
}

func (m *TickRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Codes)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	return n
}

func (m *TickReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Price != 0 {
		n += 9
	}
	if m.Date != nil {
		l = m.Date.Size()
		n += 1 + l + sovStock(uint64(l))
	}
	if m.Volume != 0 {
		n += 9
	}
	return n
}

func (m *ChartRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	if m.To != nil {
		l = m.To.Size()
		n += 1 + l + sovStock(uint64(l))
	}
	return n
}

func (m *ChartReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovStock(uint64(l))
		}
	}
	return n
}

func (m *AccountsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Accounts) > 0 {
		for _, e := range m.Accounts {
			l = e.Size()
			n += 1 + l + sovStock(uint64(l))
		}
	}
	return n
}

func (m *BuyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	if m.Otype != 0 {
		n += 1 + sovStock(uint64(m.Otype))
	}
	if m.Volume != 0 {
		n += 9
	}
	if m.Price != 0 {
		n += 9
	}
	return n
}

func (m *BuyReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	if m.AvgPrice != 0 {
		n += 9
	}
	if m.Volume != 0 {
		n += 9
	}
	if m.Fee != 0 {
		n += 9
	}
	if m.Price != 0 {
		n += 9
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovStock(uint64(l))
	}
	return n
}

func (m *SellRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	if m.Otype != 0 {
		n += 1 + sovStock(uint64(m.Otype))
	}
	if m.Volume != 0 {
		n += 9
	}
	if m.Price != 0 {
		n += 9
	}
	return n
}

func (m *SellReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	if m.AvgPrice != 0 {
		n += 9
	}
	if m.Volume != 0 {
		n += 9
	}
	if m.Fee != 0 {
		n += 9
	}
	if m.Price != 0 {
		n += 9
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovStock(uint64(l))
	}
	return n
}

func (m *ChartData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Open != 0 {
		n += 9
	}
	if m.High != 0 {
		n += 9
	}
	if m.Low != 0 {
		n += 9
	}
	if m.Close != 0 {
		n += 9
	}
	if m.Volume != 0 {
		n += 9
	}
	if m.Date != nil {
		l = m.Date.Size()
		n += 1 + l + sovStock(uint64(l))
	}
	return n
}

func (m *Order) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	if m.Side != 0 {
		n += 1 + sovStock(uint64(m.Side))
	}
	if m.Type != 0 {
		n += 1 + sovStock(uint64(m.Type))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	if m.CreatedAt != nil {
		l = m.CreatedAt.Size()
		n += 1 + l + sovStock(uint64(l))
	}
	if m.Fee != 0 {
		n += 9
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	if m.Volume != 0 {
		n += 9
	}
	if m.Price != 0 {
		n += 9
	}
	if m.TradeCount != 0 {
		n += 9
	}
	return n
}

func (m *OrderListReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Order) > 0 {
		for _, e := range m.Order {
			l = e.Size()
			n += 1 + l + sovStock(uint64(l))
		}
	}
	return n
}

func (m *CancelOrderRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	return n
}

func (m *OrderBookStreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Codes) > 0 {
		for _, s := range m.Codes {
			l = len(s)
			n += 1 + l + sovStock(uint64(l))
		}
	}
	return n
}

func (m *OrderBookStreamReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *TradeStreamRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Codes) > 0 {
		for _, s := range m.Codes {
			l = len(s)
			n += 1 + l + sovStock(uint64(l))
		}
	}
	return n
}

func (m *TradeStreamReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	if m.Price != 0 {
		n += 9
	}
	if m.Volume != 0 {
		n += 9
	}
	if m.Date != nil {
		l = m.Date.Size()
		n += 1 + l + sovStock(uint64(l))
	}
	l = len(m.Askbit)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	return n
}

func sovStock(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStock(x uint64) (n int) {
	return sovStock(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *AllMarketsReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AllMarketsReply{`,
		`Codes:` + fmt.Sprintf("%v", this.Codes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Account) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Account{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Balance:` + fmt.Sprintf("%v", this.Balance) + `,`,
		`AvgByPrice:` + fmt.Sprintf("%v", this.AvgByPrice) + `,`,
		`TotalPrice:` + fmt.Sprintf("%v", this.TotalPrice) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AccountRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AccountRequest{`,
		`Account:` + fmt.Sprintf("%v", this.Account) + `,`,
		`}`,
	}, "")
	return s
}
func (this *AccountReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&AccountReply{`,
		`Info:` + fmt.Sprintf("%v", this.Info) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TickRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TickRequest{`,
		`Codes:` + fmt.Sprintf("%v", this.Codes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TickReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TickReply{`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`Date:` + strings.Replace(fmt.Sprintf("%v", this.Date), "Timestamp", "types.Timestamp", 1) + `,`,
		`Volume:` + fmt.Sprintf("%v", this.Volume) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChartRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChartRequest{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`To:` + strings.Replace(fmt.Sprintf("%v", this.To), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChartReply) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForData := "[]*ChartData{"
	for _, f := range this.Data {
		repeatedStringForData += strings.Replace(f.String(), "ChartData", "ChartData", 1) + ","
	}
	repeatedStringForData += "}"
	s := strings.Join([]string{`&ChartReply{`,
		`Data:` + repeatedStringForData + `,`,
		`}`,
	}, "")
	return s
}
func (this *AccountsReply) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForAccounts := "[]*Account{"
	for _, f := range this.Accounts {
		repeatedStringForAccounts += strings.Replace(f.String(), "Account", "Account", 1) + ","
	}
	repeatedStringForAccounts += "}"
	s := strings.Join([]string{`&AccountsReply{`,
		`Accounts:` + repeatedStringForAccounts + `,`,
		`}`,
	}, "")
	return s
}
func (this *BuyRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BuyRequest{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Otype:` + fmt.Sprintf("%v", this.Otype) + `,`,
		`Volume:` + fmt.Sprintf("%v", this.Volume) + `,`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`}`,
	}, "")
	return s
}
func (this *BuyReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&BuyReply{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`AvgPrice:` + fmt.Sprintf("%v", this.AvgPrice) + `,`,
		`Volume:` + fmt.Sprintf("%v", this.Volume) + `,`,
		`Fee:` + fmt.Sprintf("%v", this.Fee) + `,`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`CreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SellRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SellRequest{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Otype:` + fmt.Sprintf("%v", this.Otype) + `,`,
		`Volume:` + fmt.Sprintf("%v", this.Volume) + `,`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`}`,
	}, "")
	return s
}
func (this *SellReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&SellReply{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`AvgPrice:` + fmt.Sprintf("%v", this.AvgPrice) + `,`,
		`Volume:` + fmt.Sprintf("%v", this.Volume) + `,`,
		`Fee:` + fmt.Sprintf("%v", this.Fee) + `,`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`CreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ChartData) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ChartData{`,
		`Open:` + fmt.Sprintf("%v", this.Open) + `,`,
		`High:` + fmt.Sprintf("%v", this.High) + `,`,
		`Low:` + fmt.Sprintf("%v", this.Low) + `,`,
		`Close:` + fmt.Sprintf("%v", this.Close) + `,`,
		`Volume:` + fmt.Sprintf("%v", this.Volume) + `,`,
		`Date:` + strings.Replace(fmt.Sprintf("%v", this.Date), "Timestamp", "types.Timestamp", 1) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Order) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Order{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`Side:` + fmt.Sprintf("%v", this.Side) + `,`,
		`Type:` + fmt.Sprintf("%v", this.Type) + `,`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`CreatedAt:` + strings.Replace(fmt.Sprintf("%v", this.CreatedAt), "Timestamp", "types.Timestamp", 1) + `,`,
		`Fee:` + fmt.Sprintf("%v", this.Fee) + `,`,
		`State:` + fmt.Sprintf("%v", this.State) + `,`,
		`Volume:` + fmt.Sprintf("%v", this.Volume) + `,`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`TradeCount:` + fmt.Sprintf("%v", this.TradeCount) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderListReply) String() string {
	if this == nil {
		return "nil"
	}
	repeatedStringForOrder := "[]*Order{"
	for _, f := range this.Order {
		repeatedStringForOrder += strings.Replace(f.String(), "Order", "Order", 1) + ","
	}
	repeatedStringForOrder += "}"
	s := strings.Join([]string{`&OrderListReply{`,
		`Order:` + repeatedStringForOrder + `,`,
		`}`,
	}, "")
	return s
}
func (this *CancelOrderRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CancelOrderRequest{`,
		`Id:` + fmt.Sprintf("%v", this.Id) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderBookStreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderBookStreamRequest{`,
		`Codes:` + fmt.Sprintf("%v", this.Codes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *OrderBookStreamReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&OrderBookStreamReply{`,
		`}`,
	}, "")
	return s
}
func (this *TradeStreamRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TradeStreamRequest{`,
		`Codes:` + fmt.Sprintf("%v", this.Codes) + `,`,
		`}`,
	}, "")
	return s
}
func (this *TradeStreamReply) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&TradeStreamReply{`,
		`Code:` + fmt.Sprintf("%v", this.Code) + `,`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`Volume:` + fmt.Sprintf("%v", this.Volume) + `,`,
		`Date:` + strings.Replace(fmt.Sprintf("%v", this.Date), "Timestamp", "types.Timestamp", 1) + `,`,
		`Askbit:` + fmt.Sprintf("%v", this.Askbit) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringStock(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *AllMarketsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllMarketsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllMarketsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Codes = append(m.Codes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Account) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Account: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Account: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Balance", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Balance = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgByPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AvgByPrice = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TotalPrice = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TickRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TickRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TickRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Codes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TickReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TickReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TickReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Date == nil {
				m.Date = &types.Timestamp{}
			}
			if err := m.Date.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Volume = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChartRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChartRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChartRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.To == nil {
				m.To = &types.Timestamp{}
			}
			if err := m.To.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChartReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChartReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChartReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &ChartData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accounts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Accounts = append(m.Accounts, &Account{})
			if err := m.Accounts[len(m.Accounts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Otype", wireType)
			}
			m.Otype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Otype |= OrderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Volume = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AvgPrice = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Volume = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Fee = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SellRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SellRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SellRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Otype", wireType)
			}
			m.Otype = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Otype |= OrderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Volume = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SellReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SellReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SellReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.AvgPrice = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Volume = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Fee = float64(math.Float64frombits(v))
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChartData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChartData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChartData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Open = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.High = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Low = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Close", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Close = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Volume = float64(math.Float64frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Date == nil {
				m.Date = &types.Timestamp{}
			}
			if err := m.Date.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Order) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Order: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Order: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Side", wireType)
			}
			m.Side = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Side |= Order_Side(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= OrderType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatedAt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CreatedAt == nil {
				m.CreatedAt = &types.Timestamp{}
			}
			if err := m.CreatedAt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fee", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Fee = float64(math.Float64frombits(v))
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Volume = float64(math.Float64frombits(v))
		case 9:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeCount", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.TradeCount = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderListReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderListReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderListReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Order = append(m.Order, &Order{})
			if err := m.Order[len(m.Order)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CancelOrderRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CancelOrderRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CancelOrderRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBookStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBookStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBookStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Codes = append(m.Codes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrderBookStreamReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrderBookStreamReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrderBookStreamReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradeStreamRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradeStreamRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradeStreamRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Codes = append(m.Codes, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TradeStreamReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TradeStreamReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TradeStreamReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Volume = float64(math.Float64frombits(v))
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Date == nil {
				m.Date = &types.Timestamp{}
			}
			if err := m.Date.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Askbit", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Askbit = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStock(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStock
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStock
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStock
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStock
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStock
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStock
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStock        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStock          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStock = fmt.Errorf("proto: unexpected end of group")
)
