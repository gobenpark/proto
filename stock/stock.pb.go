// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: stock/stock.proto

package stock

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AccountRequest struct {
	Account              string   `protobuf:"bytes,1,opt,name=account,proto3" json:"account,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccountRequest) Reset()         { *m = AccountRequest{} }
func (m *AccountRequest) String() string { return proto.CompactTextString(m) }
func (*AccountRequest) ProtoMessage()    {}
func (*AccountRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{0}
}
func (m *AccountRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountRequest.Merge(m, src)
}
func (m *AccountRequest) XXX_Size() int {
	return m.Size()
}
func (m *AccountRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AccountRequest proto.InternalMessageInfo

func (m *AccountRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

type AccountReply struct {
	Info                 string   `protobuf:"bytes,1,opt,name=info,proto3" json:"info,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccountReply) Reset()         { *m = AccountReply{} }
func (m *AccountReply) String() string { return proto.CompactTextString(m) }
func (*AccountReply) ProtoMessage()    {}
func (*AccountReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{1}
}
func (m *AccountReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountReply.Merge(m, src)
}
func (m *AccountReply) XXX_Size() int {
	return m.Size()
}
func (m *AccountReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountReply.DiscardUnknown(m)
}

var xxx_messageInfo_AccountReply proto.InternalMessageInfo

func (m *AccountReply) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

type TickRequest struct {
	Codes                string   `protobuf:"bytes,1,opt,name=codes,proto3" json:"codes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TickRequest) Reset()         { *m = TickRequest{} }
func (m *TickRequest) String() string { return proto.CompactTextString(m) }
func (*TickRequest) ProtoMessage()    {}
func (*TickRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{2}
}
func (m *TickRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TickRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TickRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TickRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TickRequest.Merge(m, src)
}
func (m *TickRequest) XXX_Size() int {
	return m.Size()
}
func (m *TickRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TickRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TickRequest proto.InternalMessageInfo

func (m *TickRequest) GetCodes() string {
	if m != nil {
		return m.Codes
	}
	return ""
}

type TickReply struct {
	Price                float64          `protobuf:"fixed64,1,opt,name=price,proto3" json:"price,omitempty"`
	Date                 *types.Timestamp `protobuf:"bytes,2,opt,name=date,proto3" json:"date,omitempty"`
	Volume               float64          `protobuf:"fixed64,3,opt,name=volume,proto3" json:"volume,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *TickReply) Reset()         { *m = TickReply{} }
func (m *TickReply) String() string { return proto.CompactTextString(m) }
func (*TickReply) ProtoMessage()    {}
func (*TickReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{3}
}
func (m *TickReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TickReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TickReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TickReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TickReply.Merge(m, src)
}
func (m *TickReply) XXX_Size() int {
	return m.Size()
}
func (m *TickReply) XXX_DiscardUnknown() {
	xxx_messageInfo_TickReply.DiscardUnknown(m)
}

var xxx_messageInfo_TickReply proto.InternalMessageInfo

func (m *TickReply) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *TickReply) GetDate() *types.Timestamp {
	if m != nil {
		return m.Date
	}
	return nil
}

func (m *TickReply) GetVolume() float64 {
	if m != nil {
		return m.Volume
	}
	return 0
}

type ChartRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ChartRequest) Reset()         { *m = ChartRequest{} }
func (m *ChartRequest) String() string { return proto.CompactTextString(m) }
func (*ChartRequest) ProtoMessage()    {}
func (*ChartRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{4}
}
func (m *ChartRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChartRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChartRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChartRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChartRequest.Merge(m, src)
}
func (m *ChartRequest) XXX_Size() int {
	return m.Size()
}
func (m *ChartRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ChartRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ChartRequest proto.InternalMessageInfo

type ChartReply struct {
	Data                 []*ChartData `protobuf:"bytes,1,rep,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *ChartReply) Reset()         { *m = ChartReply{} }
func (m *ChartReply) String() string { return proto.CompactTextString(m) }
func (*ChartReply) ProtoMessage()    {}
func (*ChartReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{5}
}
func (m *ChartReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChartReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChartReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChartReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChartReply.Merge(m, src)
}
func (m *ChartReply) XXX_Size() int {
	return m.Size()
}
func (m *ChartReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ChartReply.DiscardUnknown(m)
}

var xxx_messageInfo_ChartReply proto.InternalMessageInfo

func (m *ChartReply) GetData() []*ChartData {
	if m != nil {
		return m.Data
	}
	return nil
}

type AccountsReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccountsReply) Reset()         { *m = AccountsReply{} }
func (m *AccountsReply) String() string { return proto.CompactTextString(m) }
func (*AccountsReply) ProtoMessage()    {}
func (*AccountsReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{6}
}
func (m *AccountsReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccountsReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccountsReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccountsReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccountsReply.Merge(m, src)
}
func (m *AccountsReply) XXX_Size() int {
	return m.Size()
}
func (m *AccountsReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AccountsReply.DiscardUnknown(m)
}

var xxx_messageInfo_AccountsReply proto.InternalMessageInfo

type BuyRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuyRequest) Reset()         { *m = BuyRequest{} }
func (m *BuyRequest) String() string { return proto.CompactTextString(m) }
func (*BuyRequest) ProtoMessage()    {}
func (*BuyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{7}
}
func (m *BuyRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuyRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuyRequest.Merge(m, src)
}
func (m *BuyRequest) XXX_Size() int {
	return m.Size()
}
func (m *BuyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BuyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BuyRequest proto.InternalMessageInfo

type BuyReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BuyReply) Reset()         { *m = BuyReply{} }
func (m *BuyReply) String() string { return proto.CompactTextString(m) }
func (*BuyReply) ProtoMessage()    {}
func (*BuyReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{8}
}
func (m *BuyReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuyReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuyReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuyReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuyReply.Merge(m, src)
}
func (m *BuyReply) XXX_Size() int {
	return m.Size()
}
func (m *BuyReply) XXX_DiscardUnknown() {
	xxx_messageInfo_BuyReply.DiscardUnknown(m)
}

var xxx_messageInfo_BuyReply proto.InternalMessageInfo

type SellRequest struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SellRequest) Reset()         { *m = SellRequest{} }
func (m *SellRequest) String() string { return proto.CompactTextString(m) }
func (*SellRequest) ProtoMessage()    {}
func (*SellRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{9}
}
func (m *SellRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SellRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SellRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SellRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SellRequest.Merge(m, src)
}
func (m *SellRequest) XXX_Size() int {
	return m.Size()
}
func (m *SellRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SellRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SellRequest proto.InternalMessageInfo

type SellReply struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SellReply) Reset()         { *m = SellReply{} }
func (m *SellReply) String() string { return proto.CompactTextString(m) }
func (*SellReply) ProtoMessage()    {}
func (*SellReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{10}
}
func (m *SellReply) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SellReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SellReply.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SellReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SellReply.Merge(m, src)
}
func (m *SellReply) XXX_Size() int {
	return m.Size()
}
func (m *SellReply) XXX_DiscardUnknown() {
	xxx_messageInfo_SellReply.DiscardUnknown(m)
}

var xxx_messageInfo_SellReply proto.InternalMessageInfo

type ChartData struct {
	Open                 float64          `protobuf:"fixed64,1,opt,name=open,proto3" json:"open,omitempty"`
	High                 float64          `protobuf:"fixed64,2,opt,name=high,proto3" json:"high,omitempty"`
	Low                  float64          `protobuf:"fixed64,3,opt,name=low,proto3" json:"low,omitempty"`
	Close                float64          `protobuf:"fixed64,4,opt,name=close,proto3" json:"close,omitempty"`
	Volume               float64          `protobuf:"fixed64,5,opt,name=volume,proto3" json:"volume,omitempty"`
	Date                 *types.Timestamp `protobuf:"bytes,6,opt,name=date,proto3" json:"date,omitempty"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *ChartData) Reset()         { *m = ChartData{} }
func (m *ChartData) String() string { return proto.CompactTextString(m) }
func (*ChartData) ProtoMessage()    {}
func (*ChartData) Descriptor() ([]byte, []int) {
	return fileDescriptor_e6b29708bd139bde, []int{11}
}
func (m *ChartData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChartData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChartData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChartData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChartData.Merge(m, src)
}
func (m *ChartData) XXX_Size() int {
	return m.Size()
}
func (m *ChartData) XXX_DiscardUnknown() {
	xxx_messageInfo_ChartData.DiscardUnknown(m)
}

var xxx_messageInfo_ChartData proto.InternalMessageInfo

func (m *ChartData) GetOpen() float64 {
	if m != nil {
		return m.Open
	}
	return 0
}

func (m *ChartData) GetHigh() float64 {
	if m != nil {
		return m.High
	}
	return 0
}

func (m *ChartData) GetLow() float64 {
	if m != nil {
		return m.Low
	}
	return 0
}

func (m *ChartData) GetClose() float64 {
	if m != nil {
		return m.Close
	}
	return 0
}

func (m *ChartData) GetVolume() float64 {
	if m != nil {
		return m.Volume
	}
	return 0
}

func (m *ChartData) GetDate() *types.Timestamp {
	if m != nil {
		return m.Date
	}
	return nil
}

func init() {
	proto.RegisterType((*AccountRequest)(nil), "stock.AccountRequest")
	proto.RegisterType((*AccountReply)(nil), "stock.AccountReply")
	proto.RegisterType((*TickRequest)(nil), "stock.TickRequest")
	proto.RegisterType((*TickReply)(nil), "stock.TickReply")
	proto.RegisterType((*ChartRequest)(nil), "stock.ChartRequest")
	proto.RegisterType((*ChartReply)(nil), "stock.ChartReply")
	proto.RegisterType((*AccountsReply)(nil), "stock.AccountsReply")
	proto.RegisterType((*BuyRequest)(nil), "stock.BuyRequest")
	proto.RegisterType((*BuyReply)(nil), "stock.BuyReply")
	proto.RegisterType((*SellRequest)(nil), "stock.SellRequest")
	proto.RegisterType((*SellReply)(nil), "stock.SellReply")
	proto.RegisterType((*ChartData)(nil), "stock.ChartData")
}

func init() { proto.RegisterFile("stock/stock.proto", fileDescriptor_e6b29708bd139bde) }

var fileDescriptor_e6b29708bd139bde = []byte{
	// 477 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x53, 0xc1, 0x6e, 0xd3, 0x40,
	0x10, 0xed, 0x36, 0x76, 0xda, 0x8c, 0xd3, 0x36, 0x9d, 0x86, 0xca, 0x32, 0x52, 0x88, 0x16, 0x0e,
	0x11, 0x48, 0x4e, 0x09, 0x07, 0x24, 0x6e, 0x04, 0xf8, 0x01, 0xb7, 0x3f, 0xe0, 0xba, 0xdb, 0xc4,
	0xaa, 0x93, 0x35, 0xf1, 0x1a, 0x94, 0xef, 0xe1, 0x3f, 0x38, 0x73, 0xe4, 0x13, 0x50, 0xbe, 0x04,
	0xed, 0xec, 0xae, 0xeb, 0x94, 0x0b, 0x97, 0x68, 0xde, 0xcc, 0xdb, 0x59, 0xbf, 0xf7, 0x36, 0x70,
	0x5e, 0x29, 0x99, 0x3d, 0x4c, 0xe9, 0x37, 0x2e, 0x37, 0x52, 0x49, 0xf4, 0x09, 0x44, 0xcf, 0x17,
	0x52, 0x2e, 0x0a, 0x31, 0xa5, 0xe6, 0x6d, 0x7d, 0x3f, 0x15, 0xab, 0x52, 0x6d, 0x0d, 0x27, 0x7a,
	0xf1, 0x74, 0xa8, 0xf2, 0x95, 0xa8, 0x54, 0xba, 0x2a, 0x0d, 0x81, 0xbf, 0x86, 0xd3, 0x8f, 0x59,
	0x26, 0xeb, 0xb5, 0x4a, 0xc4, 0xd7, 0x5a, 0x54, 0x0a, 0x43, 0x38, 0x4a, 0x4d, 0x27, 0x64, 0x63,
	0x36, 0xe9, 0x25, 0x0e, 0x72, 0x0e, 0xfd, 0x86, 0x5b, 0x16, 0x5b, 0x44, 0xf0, 0xf2, 0xf5, 0xbd,
	0xb4, 0x34, 0xaa, 0xf9, 0x4b, 0x08, 0x6e, 0xf2, 0xec, 0xc1, 0x2d, 0x1b, 0x82, 0x9f, 0xc9, 0x3b,
	0x51, 0x59, 0x8e, 0x01, 0x3c, 0x87, 0x9e, 0x21, 0xe9, 0x2d, 0x43, 0xf0, 0xcb, 0x4d, 0x9e, 0x09,
	0xa2, 0xb0, 0xc4, 0x00, 0x8c, 0xc1, 0xbb, 0x4b, 0x95, 0x08, 0x0f, 0xc7, 0x6c, 0x12, 0xcc, 0xa2,
	0xd8, 0xe8, 0x88, 0x9d, 0x8e, 0xf8, 0xc6, 0xe9, 0x48, 0x88, 0x87, 0x97, 0xd0, 0xfd, 0x26, 0x8b,
	0x7a, 0x25, 0xc2, 0x0e, 0xad, 0xb1, 0x88, 0x9f, 0x42, 0xff, 0xd3, 0x32, 0xdd, 0x38, 0x75, 0x7c,
	0x06, 0x60, 0xb1, 0xbe, 0xfb, 0x15, 0xdd, 0x92, 0x86, 0x6c, 0xdc, 0x99, 0x04, 0xb3, 0x41, 0x6c,
	0xec, 0x25, 0xc2, 0xe7, 0x54, 0xa5, 0xb4, 0x3b, 0xe5, 0x67, 0x70, 0x62, 0x75, 0x57, 0x74, 0x8c,
	0xf7, 0x01, 0xe6, 0xf5, 0xd6, 0xad, 0x04, 0x38, 0x26, 0xa4, 0x27, 0x27, 0x10, 0x5c, 0x8b, 0xa2,
	0x70, 0xa3, 0x00, 0x7a, 0x06, 0xea, 0xd9, 0x0f, 0x06, 0xbd, 0x66, 0xb5, 0x36, 0x4f, 0x96, 0x62,
	0x6d, 0x55, 0x53, 0xad, 0x7b, 0xcb, 0x7c, 0xb1, 0x24, 0xd1, 0x2c, 0xa1, 0x1a, 0x07, 0xd0, 0x29,
	0xe4, 0x77, 0xab, 0x4a, 0x97, 0xe4, 0x69, 0x21, 0x2b, 0x11, 0x7a, 0xc6, 0x30, 0x02, 0x2d, 0x03,
	0xfc, 0xb6, 0x01, 0x8d, 0x91, 0xdd, 0xff, 0x33, 0x72, 0xf6, 0xf3, 0x10, 0xfc, 0x6b, 0x6d, 0x03,
	0xbe, 0x87, 0x23, 0x2b, 0x1b, 0x9f, 0x59, 0x67, 0xf6, 0x9f, 0x4a, 0x74, 0xf1, 0xb4, 0xad, 0x65,
	0x1e, 0xe0, 0x15, 0x78, 0x3a, 0x5e, 0x44, 0x3b, 0x6e, 0x3d, 0x88, 0x68, 0xb0, 0xd7, 0x23, 0xfe,
	0x15, 0xc3, 0xb7, 0xe0, 0x93, 0x33, 0x78, 0xd1, 0x8e, 0xc0, 0x9d, 0x39, 0xdf, 0x6f, 0x9a, 0x4b,
	0x3e, 0xc0, 0xb1, 0x0b, 0x05, 0x2f, 0xff, 0x51, 0xf5, 0x45, 0xff, 0x07, 0xa2, 0xe1, 0xfe, 0xf7,
	0x55, 0xee, 0xec, 0x1b, 0xe8, 0xcc, 0xeb, 0x2d, 0xba, 0xbd, 0x8f, 0x59, 0x46, 0x67, 0xed, 0x96,
	0x21, 0xc7, 0xe0, 0xe9, 0x0c, 0x1b, 0x35, 0xad, 0x7c, 0x1b, 0x35, 0x8f, 0x21, 0x1f, 0xcc, 0xfb,
	0xbf, 0x76, 0x23, 0xf6, 0x7b, 0x37, 0x62, 0x7f, 0x76, 0x23, 0x76, 0xdb, 0xa5, 0x4f, 0x7a, 0xf7,
	0x37, 0x00, 0x00, 0xff, 0xff, 0xc7, 0xa4, 0x58, 0x89, 0xc0, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// StockClient is the client API for Stock service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StockClient interface {
	Account(ctx context.Context, in *AccountRequest, opts ...grpc.CallOption) (*AccountReply, error)
	Tick(ctx context.Context, in *TickRequest, opts ...grpc.CallOption) (Stock_TickClient, error)
	Chart(ctx context.Context, in *ChartRequest, opts ...grpc.CallOption) (*ChartReply, error)
	Accounts(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*AccountsReply, error)
	Buy(ctx context.Context, in *BuyRequest, opts ...grpc.CallOption) (*BuyReply, error)
	Sell(ctx context.Context, in *SellRequest, opts ...grpc.CallOption) (*SellReply, error)
}

type stockClient struct {
	cc *grpc.ClientConn
}

func NewStockClient(cc *grpc.ClientConn) StockClient {
	return &stockClient{cc}
}

func (c *stockClient) Account(ctx context.Context, in *AccountRequest, opts ...grpc.CallOption) (*AccountReply, error) {
	out := new(AccountReply)
	err := c.cc.Invoke(ctx, "/stock.Stock/Account", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) Tick(ctx context.Context, in *TickRequest, opts ...grpc.CallOption) (Stock_TickClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Stock_serviceDesc.Streams[0], "/stock.Stock/Tick", opts...)
	if err != nil {
		return nil, err
	}
	x := &stockTickClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Stock_TickClient interface {
	Recv() (*TickReply, error)
	grpc.ClientStream
}

type stockTickClient struct {
	grpc.ClientStream
}

func (x *stockTickClient) Recv() (*TickReply, error) {
	m := new(TickReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *stockClient) Chart(ctx context.Context, in *ChartRequest, opts ...grpc.CallOption) (*ChartReply, error) {
	out := new(ChartReply)
	err := c.cc.Invoke(ctx, "/stock.Stock/Chart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) Accounts(ctx context.Context, in *types.Empty, opts ...grpc.CallOption) (*AccountsReply, error) {
	out := new(AccountsReply)
	err := c.cc.Invoke(ctx, "/stock.Stock/Accounts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) Buy(ctx context.Context, in *BuyRequest, opts ...grpc.CallOption) (*BuyReply, error) {
	out := new(BuyReply)
	err := c.cc.Invoke(ctx, "/stock.Stock/Buy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) Sell(ctx context.Context, in *SellRequest, opts ...grpc.CallOption) (*SellReply, error) {
	out := new(SellReply)
	err := c.cc.Invoke(ctx, "/stock.Stock/Sell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StockServer is the server API for Stock service.
type StockServer interface {
	Account(context.Context, *AccountRequest) (*AccountReply, error)
	Tick(*TickRequest, Stock_TickServer) error
	Chart(context.Context, *ChartRequest) (*ChartReply, error)
	Accounts(context.Context, *types.Empty) (*AccountsReply, error)
	Buy(context.Context, *BuyRequest) (*BuyReply, error)
	Sell(context.Context, *SellRequest) (*SellReply, error)
}

// UnimplementedStockServer can be embedded to have forward compatible implementations.
type UnimplementedStockServer struct {
}

func (*UnimplementedStockServer) Account(ctx context.Context, req *AccountRequest) (*AccountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Account not implemented")
}
func (*UnimplementedStockServer) Tick(req *TickRequest, srv Stock_TickServer) error {
	return status.Errorf(codes.Unimplemented, "method Tick not implemented")
}
func (*UnimplementedStockServer) Chart(ctx context.Context, req *ChartRequest) (*ChartReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chart not implemented")
}
func (*UnimplementedStockServer) Accounts(ctx context.Context, req *types.Empty) (*AccountsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Accounts not implemented")
}
func (*UnimplementedStockServer) Buy(ctx context.Context, req *BuyRequest) (*BuyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Buy not implemented")
}
func (*UnimplementedStockServer) Sell(ctx context.Context, req *SellRequest) (*SellReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sell not implemented")
}

func RegisterStockServer(s *grpc.Server, srv StockServer) {
	s.RegisterService(&_Stock_serviceDesc, srv)
}

func _Stock_Account_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).Account(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stock.Stock/Account",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).Account(ctx, req.(*AccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_Tick_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TickRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StockServer).Tick(m, &stockTickServer{stream})
}

type Stock_TickServer interface {
	Send(*TickReply) error
	grpc.ServerStream
}

type stockTickServer struct {
	grpc.ServerStream
}

func (x *stockTickServer) Send(m *TickReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Stock_Chart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).Chart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stock.Stock/Chart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).Chart(ctx, req.(*ChartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_Accounts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(types.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).Accounts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stock.Stock/Accounts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).Accounts(ctx, req.(*types.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_Buy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).Buy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stock.Stock/Buy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).Buy(ctx, req.(*BuyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_Sell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).Sell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/stock.Stock/Sell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).Sell(ctx, req.(*SellRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Stock_serviceDesc = grpc.ServiceDesc{
	ServiceName: "stock.Stock",
	HandlerType: (*StockServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Account",
			Handler:    _Stock_Account_Handler,
		},
		{
			MethodName: "Chart",
			Handler:    _Stock_Chart_Handler,
		},
		{
			MethodName: "Accounts",
			Handler:    _Stock_Accounts_Handler,
		},
		{
			MethodName: "Buy",
			Handler:    _Stock_Buy_Handler,
		},
		{
			MethodName: "Sell",
			Handler:    _Stock_Sell_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Tick",
			Handler:       _Stock_Tick_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "stock/stock.proto",
}

func (m *AccountRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Account) > 0 {
		i -= len(m.Account)
		copy(dAtA[i:], m.Account)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Account)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccountReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Info) > 0 {
		i -= len(m.Info)
		copy(dAtA[i:], m.Info)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Info)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TickRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TickRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TickRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Codes) > 0 {
		i -= len(m.Codes)
		copy(dAtA[i:], m.Codes)
		i = encodeVarintStock(dAtA, i, uint64(len(m.Codes)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TickReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TickReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TickReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Volume != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Volume))))
		i--
		dAtA[i] = 0x19
	}
	if m.Date != nil {
		{
			size, err := m.Date.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Price != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Price))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func (m *ChartRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChartRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChartRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ChartReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChartReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChartReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Data[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintStock(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AccountsReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccountsReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccountsReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *BuyRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuyRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *BuyReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuyReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuyReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SellRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SellRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SellRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *SellReply) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SellReply) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SellReply) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *ChartData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChartData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChartData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Date != nil {
		{
			size, err := m.Date.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintStock(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Volume != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Volume))))
		i--
		dAtA[i] = 0x29
	}
	if m.Close != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Close))))
		i--
		dAtA[i] = 0x21
	}
	if m.Low != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Low))))
		i--
		dAtA[i] = 0x19
	}
	if m.High != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.High))))
		i--
		dAtA[i] = 0x11
	}
	if m.Open != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.Open))))
		i--
		dAtA[i] = 0x9
	}
	return len(dAtA) - i, nil
}

func encodeVarintStock(dAtA []byte, offset int, v uint64) int {
	offset -= sovStock(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AccountRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Account)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccountReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TickRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Codes)
	if l > 0 {
		n += 1 + l + sovStock(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TickReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Price != 0 {
		n += 9
	}
	if m.Date != nil {
		l = m.Date.Size()
		n += 1 + l + sovStock(uint64(l))
	}
	if m.Volume != 0 {
		n += 9
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChartRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChartReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Data) > 0 {
		for _, e := range m.Data {
			l = e.Size()
			n += 1 + l + sovStock(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AccountsReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuyRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BuyReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SellRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *SellReply) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ChartData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Open != 0 {
		n += 9
	}
	if m.High != 0 {
		n += 9
	}
	if m.Low != 0 {
		n += 9
	}
	if m.Close != 0 {
		n += 9
	}
	if m.Volume != 0 {
		n += 9
	}
	if m.Date != nil {
		l = m.Date.Size()
		n += 1 + l + sovStock(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovStock(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozStock(x uint64) (n int) {
	return sovStock(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AccountRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Account", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Account = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TickRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TickRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TickRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Codes", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Codes = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TickReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TickReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TickReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Price = float64(math.Float64frombits(v))
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Date == nil {
				m.Date = &types.Timestamp{}
			}
			if err := m.Date.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Volume = float64(math.Float64frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChartRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChartRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChartRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChartReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChartReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChartReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, &ChartData{})
			if err := m.Data[len(m.Data)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccountsReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccountsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccountsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuyReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuyReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuyReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SellRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SellRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SellRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SellReply) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SellReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SellReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChartData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStock
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChartData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChartData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Open", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Open = float64(math.Float64frombits(v))
		case 2:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field High", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.High = float64(math.Float64frombits(v))
		case 3:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Low", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Low = float64(math.Float64frombits(v))
		case 4:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Close", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Close = float64(math.Float64frombits(v))
		case 5:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Volume", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.Volume = float64(math.Float64frombits(v))
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStock
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStock
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthStock
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Date == nil {
				m.Date = &types.Timestamp{}
			}
			if err := m.Date.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStock(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthStock
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStock(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStock
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStock
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStock
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthStock
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupStock
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthStock
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthStock        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStock          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupStock = fmt.Errorf("proto: unexpected end of group")
)
