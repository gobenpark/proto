// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package stock

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// StockClient is the client API for Stock service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StockClient interface {
	AllMarkets(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AllMarketsReply, error)
	//특정 소유하고 있는 주식,코인 정보
	Account(ctx context.Context, in *AccountRequest, opts ...grpc.CallOption) (*AccountReply, error)
	TickStream(ctx context.Context, in *TickRequest, opts ...grpc.CallOption) (Stock_TickStreamClient, error)
	Chart(ctx context.Context, in *ChartRequest, opts ...grpc.CallOption) (*ChartReply, error)
	//모든 소유하고 있는 주식, 코인정보
	Position(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PositionReply, error)
	Buy(ctx context.Context, in *BuyRequest, opts ...grpc.CallOption) (*BuyReply, error)
	Sell(ctx context.Context, in *SellRequest, opts ...grpc.CallOption) (*SellReply, error)
	OrderList(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*OrderListReply, error)
	CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	TradeStream(ctx context.Context, in *TradeStreamRequest, opts ...grpc.CallOption) (Stock_TradeStreamClient, error)
	OrderBookStream(ctx context.Context, in *OrderBookStreamRequest, opts ...grpc.CallOption) (Stock_OrderBookStreamClient, error)
	OrderInfo(ctx context.Context, in *OrderInfoRequest, opts ...grpc.CallOption) (*OrderInfoReply, error)
	OrderEventStream(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (Stock_OrderEventStreamClient, error)
}

type stockClient struct {
	cc grpc.ClientConnInterface
}

func NewStockClient(cc grpc.ClientConnInterface) StockClient {
	return &stockClient{cc}
}

func (c *stockClient) AllMarkets(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*AllMarketsReply, error) {
	out := new(AllMarketsReply)
	err := c.cc.Invoke(ctx, "/Stock/AllMarkets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) Account(ctx context.Context, in *AccountRequest, opts ...grpc.CallOption) (*AccountReply, error) {
	out := new(AccountReply)
	err := c.cc.Invoke(ctx, "/Stock/Account", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) TickStream(ctx context.Context, in *TickRequest, opts ...grpc.CallOption) (Stock_TickStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Stock_ServiceDesc.Streams[0], "/Stock/TickStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &stockTickStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Stock_TickStreamClient interface {
	Recv() (*TickReply, error)
	grpc.ClientStream
}

type stockTickStreamClient struct {
	grpc.ClientStream
}

func (x *stockTickStreamClient) Recv() (*TickReply, error) {
	m := new(TickReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *stockClient) Chart(ctx context.Context, in *ChartRequest, opts ...grpc.CallOption) (*ChartReply, error) {
	out := new(ChartReply)
	err := c.cc.Invoke(ctx, "/Stock/Chart", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) Position(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*PositionReply, error) {
	out := new(PositionReply)
	err := c.cc.Invoke(ctx, "/Stock/Position", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) Buy(ctx context.Context, in *BuyRequest, opts ...grpc.CallOption) (*BuyReply, error) {
	out := new(BuyReply)
	err := c.cc.Invoke(ctx, "/Stock/Buy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) Sell(ctx context.Context, in *SellRequest, opts ...grpc.CallOption) (*SellReply, error) {
	out := new(SellReply)
	err := c.cc.Invoke(ctx, "/Stock/Sell", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) OrderList(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*OrderListReply, error) {
	out := new(OrderListReply)
	err := c.cc.Invoke(ctx, "/Stock/OrderList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) CancelOrder(ctx context.Context, in *CancelOrderRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/Stock/CancelOrder", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) TradeStream(ctx context.Context, in *TradeStreamRequest, opts ...grpc.CallOption) (Stock_TradeStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Stock_ServiceDesc.Streams[1], "/Stock/TradeStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &stockTradeStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Stock_TradeStreamClient interface {
	Recv() (*TradeStreamReply, error)
	grpc.ClientStream
}

type stockTradeStreamClient struct {
	grpc.ClientStream
}

func (x *stockTradeStreamClient) Recv() (*TradeStreamReply, error) {
	m := new(TradeStreamReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *stockClient) OrderBookStream(ctx context.Context, in *OrderBookStreamRequest, opts ...grpc.CallOption) (Stock_OrderBookStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Stock_ServiceDesc.Streams[2], "/Stock/OrderBookStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &stockOrderBookStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Stock_OrderBookStreamClient interface {
	Recv() (*OrderBookStreamReply, error)
	grpc.ClientStream
}

type stockOrderBookStreamClient struct {
	grpc.ClientStream
}

func (x *stockOrderBookStreamClient) Recv() (*OrderBookStreamReply, error) {
	m := new(OrderBookStreamReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *stockClient) OrderInfo(ctx context.Context, in *OrderInfoRequest, opts ...grpc.CallOption) (*OrderInfoReply, error) {
	out := new(OrderInfoReply)
	err := c.cc.Invoke(ctx, "/Stock/OrderInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *stockClient) OrderEventStream(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (Stock_OrderEventStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Stock_ServiceDesc.Streams[3], "/Stock/OrderEventStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &stockOrderEventStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Stock_OrderEventStreamClient interface {
	Recv() (*OrderEventStreamReply, error)
	grpc.ClientStream
}

type stockOrderEventStreamClient struct {
	grpc.ClientStream
}

func (x *stockOrderEventStreamClient) Recv() (*OrderEventStreamReply, error) {
	m := new(OrderEventStreamReply)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// StockServer is the server API for Stock service.
// All implementations must embed UnimplementedStockServer
// for forward compatibility
type StockServer interface {
	AllMarkets(context.Context, *emptypb.Empty) (*AllMarketsReply, error)
	//특정 소유하고 있는 주식,코인 정보
	Account(context.Context, *AccountRequest) (*AccountReply, error)
	TickStream(*TickRequest, Stock_TickStreamServer) error
	Chart(context.Context, *ChartRequest) (*ChartReply, error)
	//모든 소유하고 있는 주식, 코인정보
	Position(context.Context, *emptypb.Empty) (*PositionReply, error)
	Buy(context.Context, *BuyRequest) (*BuyReply, error)
	Sell(context.Context, *SellRequest) (*SellReply, error)
	OrderList(context.Context, *emptypb.Empty) (*OrderListReply, error)
	CancelOrder(context.Context, *CancelOrderRequest) (*emptypb.Empty, error)
	TradeStream(*TradeStreamRequest, Stock_TradeStreamServer) error
	OrderBookStream(*OrderBookStreamRequest, Stock_OrderBookStreamServer) error
	OrderInfo(context.Context, *OrderInfoRequest) (*OrderInfoReply, error)
	OrderEventStream(*emptypb.Empty, Stock_OrderEventStreamServer) error
	mustEmbedUnimplementedStockServer()
}

// UnimplementedStockServer must be embedded to have forward compatible implementations.
type UnimplementedStockServer struct {
}

func (UnimplementedStockServer) AllMarkets(context.Context, *emptypb.Empty) (*AllMarketsReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AllMarkets not implemented")
}
func (UnimplementedStockServer) Account(context.Context, *AccountRequest) (*AccountReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Account not implemented")
}
func (UnimplementedStockServer) TickStream(*TickRequest, Stock_TickStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method TickStream not implemented")
}
func (UnimplementedStockServer) Chart(context.Context, *ChartRequest) (*ChartReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Chart not implemented")
}
func (UnimplementedStockServer) Position(context.Context, *emptypb.Empty) (*PositionReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Position not implemented")
}
func (UnimplementedStockServer) Buy(context.Context, *BuyRequest) (*BuyReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Buy not implemented")
}
func (UnimplementedStockServer) Sell(context.Context, *SellRequest) (*SellReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Sell not implemented")
}
func (UnimplementedStockServer) OrderList(context.Context, *emptypb.Empty) (*OrderListReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderList not implemented")
}
func (UnimplementedStockServer) CancelOrder(context.Context, *CancelOrderRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelOrder not implemented")
}
func (UnimplementedStockServer) TradeStream(*TradeStreamRequest, Stock_TradeStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method TradeStream not implemented")
}
func (UnimplementedStockServer) OrderBookStream(*OrderBookStreamRequest, Stock_OrderBookStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method OrderBookStream not implemented")
}
func (UnimplementedStockServer) OrderInfo(context.Context, *OrderInfoRequest) (*OrderInfoReply, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OrderInfo not implemented")
}
func (UnimplementedStockServer) OrderEventStream(*emptypb.Empty, Stock_OrderEventStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method OrderEventStream not implemented")
}
func (UnimplementedStockServer) mustEmbedUnimplementedStockServer() {}

// UnsafeStockServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StockServer will
// result in compilation errors.
type UnsafeStockServer interface {
	mustEmbedUnimplementedStockServer()
}

func RegisterStockServer(s grpc.ServiceRegistrar, srv StockServer) {
	s.RegisterService(&Stock_ServiceDesc, srv)
}

func _Stock_AllMarkets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).AllMarkets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Stock/AllMarkets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).AllMarkets(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_Account_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).Account(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Stock/Account",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).Account(ctx, req.(*AccountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_TickStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TickRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StockServer).TickStream(m, &stockTickStreamServer{stream})
}

type Stock_TickStreamServer interface {
	Send(*TickReply) error
	grpc.ServerStream
}

type stockTickStreamServer struct {
	grpc.ServerStream
}

func (x *stockTickStreamServer) Send(m *TickReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Stock_Chart_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChartRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).Chart(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Stock/Chart",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).Chart(ctx, req.(*ChartRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_Position_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).Position(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Stock/Position",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).Position(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_Buy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).Buy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Stock/Buy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).Buy(ctx, req.(*BuyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_Sell_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SellRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).Sell(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Stock/Sell",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).Sell(ctx, req.(*SellRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_OrderList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).OrderList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Stock/OrderList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).OrderList(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_CancelOrder_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelOrderRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).CancelOrder(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Stock/CancelOrder",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).CancelOrder(ctx, req.(*CancelOrderRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_TradeStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(TradeStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StockServer).TradeStream(m, &stockTradeStreamServer{stream})
}

type Stock_TradeStreamServer interface {
	Send(*TradeStreamReply) error
	grpc.ServerStream
}

type stockTradeStreamServer struct {
	grpc.ServerStream
}

func (x *stockTradeStreamServer) Send(m *TradeStreamReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Stock_OrderBookStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(OrderBookStreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StockServer).OrderBookStream(m, &stockOrderBookStreamServer{stream})
}

type Stock_OrderBookStreamServer interface {
	Send(*OrderBookStreamReply) error
	grpc.ServerStream
}

type stockOrderBookStreamServer struct {
	grpc.ServerStream
}

func (x *stockOrderBookStreamServer) Send(m *OrderBookStreamReply) error {
	return x.ServerStream.SendMsg(m)
}

func _Stock_OrderInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(OrderInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StockServer).OrderInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/Stock/OrderInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StockServer).OrderInfo(ctx, req.(*OrderInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Stock_OrderEventStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(emptypb.Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(StockServer).OrderEventStream(m, &stockOrderEventStreamServer{stream})
}

type Stock_OrderEventStreamServer interface {
	Send(*OrderEventStreamReply) error
	grpc.ServerStream
}

type stockOrderEventStreamServer struct {
	grpc.ServerStream
}

func (x *stockOrderEventStreamServer) Send(m *OrderEventStreamReply) error {
	return x.ServerStream.SendMsg(m)
}

// Stock_ServiceDesc is the grpc.ServiceDesc for Stock service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Stock_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "Stock",
	HandlerType: (*StockServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AllMarkets",
			Handler:    _Stock_AllMarkets_Handler,
		},
		{
			MethodName: "Account",
			Handler:    _Stock_Account_Handler,
		},
		{
			MethodName: "Chart",
			Handler:    _Stock_Chart_Handler,
		},
		{
			MethodName: "Position",
			Handler:    _Stock_Position_Handler,
		},
		{
			MethodName: "Buy",
			Handler:    _Stock_Buy_Handler,
		},
		{
			MethodName: "Sell",
			Handler:    _Stock_Sell_Handler,
		},
		{
			MethodName: "OrderList",
			Handler:    _Stock_OrderList_Handler,
		},
		{
			MethodName: "CancelOrder",
			Handler:    _Stock_CancelOrder_Handler,
		},
		{
			MethodName: "OrderInfo",
			Handler:    _Stock_OrderInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "TickStream",
			Handler:       _Stock_TickStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "TradeStream",
			Handler:       _Stock_TradeStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "OrderBookStream",
			Handler:       _Stock_OrderBookStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "OrderEventStream",
			Handler:       _Stock_OrderEventStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "stock/stock.proto",
}
